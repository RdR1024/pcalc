
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Welcome to pcalc’s source code documentation! &#8212; pcalc 0.9.0 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="welcome-to-pcalc-s-source-code-documentation">
<h1>Welcome to pcalc’s source code documentation!<a class="headerlink" href="#welcome-to-pcalc-s-source-code-documentation" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
</div>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>The pcalc module (<cite>pcalc.js</cite>) is actually a pre-packaged .js file that contains three major (sub-) modules. The first is a wrapper that provides the main (html) interface to the calculator.  This interface is intended to be very loosely coupled with any actual HTML page you might have.  Your HTML page simply feeds the html content as a string to <a class="reference internal" href="#calcvars" title="calcvars"><code class="xref js js-func docutils literal notranslate"><span class="pre">calcvars()</span></code></a>, which will do the calculation of any formulas (inside backticks) in the html content and returns a modified html string for you to display.  The modified html string will have placed the formulas inside <cite>&lt;code class=”pcalc”&gt;&lt;span class=”formula.”&gt;…&lt;/span&gt;&lt;span class=”result.”&gt;…&lt;/span&gt;&lt;/code&gt;</cite> tags. You can find details on tag structure in the <a class="reference internal" href="#tickconvert" title="tickconvert"><code class="xref js js-func docutils literal notranslate"><span class="pre">tickconvert()</span></code></a> documentation.</p>
<p>The other functions in the wrapper section (i.e. <a class="reference internal" href="#calcs" title="calcs"><code class="xref js js-func docutils literal notranslate"><span class="pre">calcs()</span></code></a>, <a class="reference internal" href="#sortfs" title="sortfs"><code class="xref js js-func docutils literal notranslate"><span class="pre">sortfs()</span></code></a>, <a class="reference internal" href="#height" title="height"><code class="xref js js-func docutils literal notranslate"><span class="pre">height()</span></code></a>, <a class="reference internal" href="#tickconvert" title="tickconvert"><code class="xref js js-func docutils literal notranslate"><span class="pre">tickconvert()</span></code></a>, and <a class="reference internal" href="#highlight" title="highlight"><code class="xref js js-func docutils literal notranslate"><span class="pre">highlight()</span></code></a> ) are mainly there to support <a class="reference internal" href="#calcvars" title="calcvars"><code class="xref js js-func docutils literal notranslate"><span class="pre">calcvars()</span></code></a>.  There is also a function (i.e. <a class="reference internal" href="#resetcode" title="resetcode"><code class="xref js js-func docutils literal notranslate"><span class="pre">resetcode()</span></code></a>) that removes the <cite>&lt;code&gt;</cite> tags and calculation results and restores formulas to be inside the original backticks.  The <a class="reference internal" href="#sortfs" title="sortfs"><code class="xref js js-func docutils literal notranslate"><span class="pre">sortfs()</span></code></a> function (and its sub-function <a class="reference internal" href="#height" title="height"><code class="xref js js-func docutils literal notranslate"><span class="pre">height()</span></code></a>) are worth noting, because they put probability formulas in the right order for calculation.  With probability formulas, you have to make sure that you evaluate the formulas with conditions (i.e. dependencies on other variables) in the right order of dependency.  For example, suppose you have the following formulas:</p>
<blockquote>
<div><p><cite>pr Y given X is 50%</cite></p>
<p><cite>pr X is 20%</cite></p>
</div></blockquote>
<p>You have to evaluate the last formula first, because Y depends on having a value for X.  The <a class="reference internal" href="#sortfs" title="sortfs"><code class="xref js js-func docutils literal notranslate"><span class="pre">sortfs()</span></code></a> performs this task. One more point worth noting is that <code class="xref js js-func docutils literal notranslate"><span class="pre">sorfs()</span></code> also constructs a global object called <cite>Dlist</cite> which contains all the variables from all the formulas and has a simple dependency list for each.  For example, if the text contains the following formulas, <cite>pr X=0.5</cite>, <cite>pr Y given X = 0.2</cite> and <cite>pr Z given X or Y = 0.5</cite>, then <cite>Dlist</cite> will contain the following:</p>
<blockquote>
<div>{ “X”:null, “Y”:[“X”], “Z”:[“X”,”Y”] }</div></blockquote>
<p>The next major section starts with the function <a class="reference internal" href="#pcalc" title="pcalc"><code class="xref js js-func docutils literal notranslate"><span class="pre">pcalc()</span></code></a> and comprises the formula interpreter. This formula interpreter is called for every formula in the html content, from the function <a class="reference internal" href="#calcs" title="calcs"><code class="xref js js-func docutils literal notranslate"><span class="pre">calcs()</span></code></a> in the wrapper section.  The formula interpreter will use “assignment formulas” to update an object (typically called “U”) which ultimately contains the probability network variables and their definitions.  This object is then used later to calculate the results of formulas.  Even though <a class="reference internal" href="#pcalc" title="pcalc"><code class="xref js js-func docutils literal notranslate"><span class="pre">pcalc()</span></code></a> only interpretes one formula at the time, the <cite>U</cite> object stores or updates any variable assignments.  This way, successive calls to <a class="reference internal" href="#pcalc" title="pcalc"><code class="xref js js-func docutils literal notranslate"><span class="pre">pcalc()</span></code></a> will incrementally build the probability network in <cite>U</cite>. The wrapper section initialises <cite>U</cite>, which is by default not global.  However, for debugging, <cite>U</cite> can easily be made a global object (see the commented out lines in <a class="reference internal" href="#calcvars" title="calcvars"><code class="xref js js-func docutils literal notranslate"><span class="pre">calcvars()</span></code></a>).</p>
<div class="section" id="overview-of-the-interpreter-sub-module">
<h3>Overview of the interpreter sub-module<a class="headerlink" href="#overview-of-the-interpreter-sub-module" title="Permalink to this headline">¶</a></h3>
<p>The function <a class="reference internal" href="#pcalc" title="pcalc"><code class="xref js js-func docutils literal notranslate"><span class="pre">pcalc()</span></code></a> is essentially the start of a recursive descent interpreter that translates the formulas into a more easily computable structure, which is passed to the third major sub-module, which is the computational engine for probability networks (more on that later).  We can play with <a class="reference internal" href="#pcalc" title="pcalc"><code class="xref js js-func docutils literal notranslate"><span class="pre">pcalc()</span></code></a> from the node commandline (or the browser console), as long as we pass it a “User space” object.  An empty object can be defined on the commandline as follows:</p>
<blockquote>
<div><strong>&gt;</strong> var U = { id:”my space”, nonp:{} }</div></blockquote>
<p>We can then apply <a class="reference internal" href="#pcalc" title="pcalc"><code class="xref js js-func docutils literal notranslate"><span class="pre">pcalc()</span></code></a>, for example:</p>
<blockquote>
<div><strong>&gt;</strong> pcalc(‘pr X=50%’,U)</div></blockquote>
<p>We then see that the probability variable has been added to <cite>U</cite>:</p>
<blockquote>
<div><p><strong>&gt;</strong> U</p>
<p>// result is:</p>
<p>{ id: ‘my space’, nonp: {}, X: { true: 0.5 } }</p>
</div></blockquote>
<p>In case you’re wondering what the <cite>nonp</cite> is for:  it holds non-probabilistic variables.  For example,</p>
<blockquote>
<div><p><strong>&gt;</strong> pcalc(‘X = 3’,U)</p>
<p><strong>&gt;</strong> U</p>
<p>// result is:</p>
<p>{ id: ‘my space’, nonp: { X: 3 }, X: { true: 0.5 } }</p>
<p><strong>&gt;</strong> pcalc(‘1+2*X’,U)</p>
<p>// result is:</p>
<p>7</p>
</div></blockquote>
<p>From the examples above, it should be clear that the “wrapper” section of <cite>pcalc.js</cite> mostly extracts a list of formulas from the html content and passes each formula to <a class="reference internal" href="#pcalc" title="pcalc"><code class="xref js js-func docutils literal notranslate"><span class="pre">pcalc()</span></code></a>, together with a user space object that will hold all the probability variable definitions (as well as any non-probability variables, but we’ll ignore that for the moment).  Here is an example of how to construct a probability network from the commandline, using <a class="reference internal" href="#pcalc" title="pcalc"><code class="xref js js-func docutils literal notranslate"><span class="pre">pcalc()</span></code></a>:</p>
<div class="highlight-js notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">W</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">id</span><span class="o">:</span><span class="s2">&quot;wet grass&quot;</span><span class="p">,</span> <span class="nx">nonp</span><span class="o">:</span><span class="p">{}</span> <span class="p">}</span>
<span class="nx">pcalc</span><span class="p">(</span><span class="s2">&quot;pr Rain=20%&quot;</span><span class="p">,</span> <span class="nx">W</span><span class="p">)</span>
<span class="nx">pcalc</span><span class="p">(</span><span class="s2">&quot;pr Sprinkler given Rain=1%&quot;</span><span class="p">,</span> <span class="nx">W</span><span class="p">)</span>
<span class="nx">pcalc</span><span class="p">(</span><span class="s2">&quot;pr Sprinkler given not Rain=40%&quot;</span><span class="p">,</span> <span class="nx">W</span><span class="p">)</span>
<span class="nx">pcalc</span><span class="p">(</span><span class="s2">&quot;pr WetGrass given not Sprinkler and not Rain = 0%&quot;</span><span class="p">,</span> <span class="nx">W</span><span class="p">)</span>
<span class="nx">pcalc</span><span class="p">(</span><span class="s2">&quot;pr WetGrass given not Sprinkler and Rain = 80%&quot;</span><span class="p">,</span> <span class="nx">W</span><span class="p">)</span>
<span class="nx">pcalc</span><span class="p">(</span><span class="s2">&quot;pr WetGrass given Sprinkler and not Rain = 90%&quot;</span><span class="p">,</span> <span class="nx">W</span><span class="p">)</span>
<span class="nx">pcalc</span><span class="p">(</span><span class="s2">&quot;pr WetGrass given Sprinkler and Rain = 99%&quot;</span><span class="p">,</span> <span class="nx">W</span><span class="p">)</span>
</pre></div>
</div>
<p>We can then inspect the probability network (i.e. Bayes net) created in <cite>W</cite>. We’ll use the <cite>print.js</cite> utility to see the unabbreviated content:</p>
<div class="highlight-js notranslate"><div class="highlight"><pre><span></span> <span class="p">.</span><span class="nx">load</span> <span class="nx">print</span><span class="p">.</span><span class="nx">js</span>
 <span class="nx">print</span><span class="p">(</span><span class="nx">W</span><span class="p">)</span>

<span class="c1">// result is:</span>

<span class="p">{</span> <span class="nx">id</span><span class="o">:</span> <span class="s1">&#39;wet grass&#39;</span><span class="p">,</span>
    <span class="nx">nonp</span><span class="o">:</span> <span class="p">{},</span>
    <span class="nx">Rain</span><span class="o">:</span> <span class="p">{</span> <span class="kc">true</span><span class="o">:</span> <span class="mf">0.2</span> <span class="p">},</span>
    <span class="nx">Sprinkler</span><span class="o">:</span> <span class="p">{</span> <span class="s1">&#39;#&#39;</span><span class="o">:</span> <span class="p">[</span> <span class="p">[</span> <span class="mf">0.01</span><span class="p">,</span> <span class="s1">&#39;Rain&#39;</span> <span class="p">],</span> <span class="p">[</span> <span class="mf">0.4</span><span class="p">,</span> <span class="p">[</span> <span class="s1">&#39;not&#39;</span><span class="p">,</span> <span class="s1">&#39;Rain&#39;</span> <span class="p">]</span> <span class="p">]</span> <span class="p">]</span> <span class="p">},</span>
    <span class="nx">WetGrass</span><span class="o">:</span>
        <span class="p">{</span> <span class="s1">&#39;#&#39;</span><span class="o">:</span>
            <span class="p">[</span> <span class="p">[</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[</span> <span class="s1">&#39;and&#39;</span><span class="p">,</span> <span class="p">[</span> <span class="s1">&#39;not&#39;</span><span class="p">,</span> <span class="s1">&#39;Sprinkler&#39;</span> <span class="p">],</span> <span class="p">[</span> <span class="s1">&#39;not&#39;</span><span class="p">,</span> <span class="s1">&#39;Rain&#39;</span> <span class="p">]</span> <span class="p">]</span> <span class="p">],</span>
            <span class="p">[</span> <span class="mf">0.8</span><span class="p">,</span> <span class="p">[</span> <span class="s1">&#39;and&#39;</span><span class="p">,</span> <span class="p">[</span> <span class="s1">&#39;not&#39;</span><span class="p">,</span> <span class="s1">&#39;Sprinkler&#39;</span> <span class="p">],</span> <span class="s1">&#39;Rain&#39;</span> <span class="p">]</span> <span class="p">],</span>
            <span class="p">[</span> <span class="mf">0.9</span><span class="p">,</span> <span class="p">[</span> <span class="s1">&#39;and&#39;</span><span class="p">,</span> <span class="s1">&#39;Sprinkler&#39;</span><span class="p">,</span> <span class="p">[</span> <span class="s1">&#39;not&#39;</span><span class="p">,</span> <span class="s1">&#39;Rain&#39;</span> <span class="p">]</span> <span class="p">]</span> <span class="p">],</span>
            <span class="p">[</span> <span class="mf">0.99</span><span class="p">,</span> <span class="p">[</span> <span class="s1">&#39;and&#39;</span><span class="p">,</span> <span class="s1">&#39;Sprinkler&#39;</span><span class="p">,</span> <span class="s1">&#39;Rain&#39;</span> <span class="p">]</span> <span class="p">]</span> <span class="p">]</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The resulting user space object is a straight-forward javascript object.  It could be created manually, or perhaps imported via JSON.  The object structure also shows much of how probability formulas are represented internally.  Essentially, the logic component of a formula is represented using operator-prefix lists.  For example, [“and”,”X”,”Y”,”Z”] represents the conjunction of X,Y and Z.  We’ll come back to that in the evaluation sub-module, but for now we’ll note that the interpreter simply translates more conventially written formulas into this internal structure.</p>
<p>Note that the <a class="reference internal" href="#pcalc" title="pcalc"><code class="xref js js-func docutils literal notranslate"><span class="pre">pcalc()</span></code></a> interpreter doesn’t only interpret probability formulas, but can handle basic arithmetic as well.  For example, try <cite>pcalc(“1+2*3”,U)</cite>.</p>
<p>The recursive descent interpreter consists of a collection of functions, each of which looks at the next token(s) in the list and decides if those tokens match what the function is looking for.  The result of each function is returned in this general structure:</p>
<div class="highlight-js notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="nx">err</span><span class="o">:</span> <span class="nx">ErrorStatus</span><span class="p">,</span> <span class="nx">val</span><span class="o">:</span> <span class="nx">ValueOfTheInterpretation</span><span class="p">,</span> <span class="nx">tail</span><span class="o">:</span> <span class="nx">RestOfTheTokens</span><span class="p">}</span>
</pre></div>
</div>
<p>The interpreter will evaluate the expressions it’s given and return a result back to the top level function (i.e. <a class="reference internal" href="#pcalc" title="pcalc"><code class="xref js js-func docutils literal notranslate"><span class="pre">pcalc()</span></code></a>).  However, the as far as probability formulas is concerned, the interpreter is a “lazy interpreter” – it waits until the last possible moment to evaluate the formula.  In fact, there are only two functions where that evaluation takes place: <a class="reference internal" href="#pexpression" title="pexpression"><code class="xref js js-func docutils literal notranslate"><span class="pre">pexpression()</span></code></a> and <a class="reference internal" href="#vgiven" title="vgiven"><code class="xref js js-func docutils literal notranslate"><span class="pre">vgiven()</span></code></a>, both of which call the function <code class="xref js js-func docutils literal notranslate"><span class="pre">prob()</span></code> after they get the result from the expression parser <a class="reference internal" href="#pexp" title="pexp"><code class="xref js js-func docutils literal notranslate"><span class="pre">pexp()</span></code></a>.</p>
<p>You can play around with probability formulas (the logic part) without actually evaluating them. Try the following:</p>
<div class="highlight-js notranslate"><div class="highlight"><pre><span></span><span class="nx">print</span><span class="p">(</span> <span class="nx">pexp</span><span class="p">([</span><span class="s2">&quot;X&quot;</span><span class="p">,</span><span class="nx">and</span><span class="p">,</span><span class="s2">&quot;Y&quot;</span><span class="p">,</span><span class="nx">or</span><span class="p">,</span><span class="nx">not</span><span class="p">,</span><span class="s2">&quot;Z&quot;</span><span class="p">],</span><span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="p">)</span>

<span class="c1">// result is:</span>
<span class="p">{</span> <span class="nx">err</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
  <span class="nx">val</span><span class="o">:</span> <span class="p">[</span> <span class="s1">&#39;and&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="p">[</span> <span class="s1">&#39;or&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="p">[</span> <span class="s1">&#39;not&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span> <span class="p">]</span> <span class="p">]</span> <span class="p">],</span>
  <span class="nx">tail</span><span class="o">:</span> <span class="p">[]</span> <span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="overview-of-the-probability-calculator-sub-module">
<h3>Overview of the probability calculator sub-module<a class="headerlink" href="#overview-of-the-probability-calculator-sub-module" title="Permalink to this headline">¶</a></h3>
<p>Once the interpreter has translated the probability formula into the internal operator-prefix structure, and updated the user space with the variable assignments, we can calculate probability results with the <code class="xref js js-func docutils literal notranslate"><span class="pre">prob()</span></code> function.  This function requires a formula in prefix notation and a user space object and returns the resulting probability.</p>
<p>Note that there is one intermediate step necessary before we can use a user space object.  That is, we need to run the <code class="xref js js-func docutils literal notranslate"><span class="pre">completor()</span></code> function over the user space object, to ensure that all the conditional variables in the probability network have a <em>complete</em> set of conditions.  If the conditions are only partially defined, then the <code class="xref js js-func docutils literal notranslate"><span class="pre">completor()</span></code> function will detect that and apply the “noisy-or” algorithm to try and complete the conditions.  The “noisy-or” algorithm essentially calculates for each combination of dependent variables the negation of the product of negated positive dependent variables.  For example, assume that we have defined the following probability network:</p>
<div class="highlight-js notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">mynet</span> <span class="o">=</span> <span class="p">{</span><span class="nx">id</span><span class="o">:</span><span class="s2">&quot;mynet&quot;</span><span class="p">,</span>
    <span class="nx">X</span><span class="o">:</span> <span class="p">{</span><span class="kc">true</span><span class="o">:</span> <span class="mf">0.2</span><span class="p">},</span>
    <span class="nx">Y</span><span class="o">:</span> <span class="p">{</span><span class="kc">true</span><span class="o">:</span> <span class="mf">0.8</span><span class="p">},</span>
    <span class="nx">Z</span><span class="o">:</span> <span class="p">{</span><span class="s2">&quot;#&quot;</span><span class="o">:</span> <span class="p">[</span>  <span class="p">[</span><span class="mf">0.9</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">]</span> <span class="p">]}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Notice that the conditions of “Z” are combinatorially incomplete.  For instance, there is no definition for the conditional probability of “Z” when “X” is true, but “Y” is false.  The function <code class="xref js js-func docutils literal notranslate"><span class="pre">completor()</span></code> will detect that and apply the “noisy-or” algorithm.  At the node command line (after loading pcalc.js), enter the above probability network and then try the following:</p>
<div class="highlight-js notranslate"><div class="highlight"><pre><span></span><span class="nx">completor</span><span class="p">(</span><span class="nx">mynet</span><span class="p">)</span>
<span class="nx">print</span><span class="p">(</span><span class="nx">mynet</span><span class="p">)</span>

<span class="c1">// result is (numbers rounded for readability):</span>

<span class="p">{</span>   <span class="nx">id</span><span class="o">:</span> <span class="s1">&#39;mynet&#39;</span><span class="p">,</span>
    <span class="nx">X</span><span class="o">:</span> <span class="p">{</span> <span class="kc">true</span><span class="o">:</span> <span class="mf">0.2</span> <span class="p">},</span>
    <span class="nx">Y</span><span class="o">:</span> <span class="p">{</span> <span class="kc">true</span><span class="o">:</span> <span class="mf">0.8</span> <span class="p">},</span>
    <span class="nx">Z</span><span class="o">:</span> <span class="p">{</span> <span class="s1">&#39;#&#39;</span><span class="o">:</span>
        <span class="p">[</span> <span class="p">[</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[</span> <span class="s1">&#39;and&#39;</span><span class="p">,</span> <span class="p">[</span> <span class="s1">&#39;not&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span> <span class="p">],</span> <span class="p">[</span> <span class="s1">&#39;not&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span> <span class="p">]</span> <span class="p">]</span> <span class="p">],</span>
        <span class="p">[</span> <span class="mf">0.01</span><span class="p">,</span> <span class="p">[</span> <span class="s1">&#39;and&#39;</span><span class="p">,</span> <span class="p">[</span> <span class="s1">&#39;not&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span> <span class="p">],</span> <span class="s1">&#39;Y&#39;</span> <span class="p">]</span> <span class="p">],</span>
        <span class="p">[</span> <span class="mf">0.9</span><span class="p">,</span> <span class="p">[</span> <span class="s1">&#39;and&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="p">[</span> <span class="s1">&#39;not&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span> <span class="p">]</span> <span class="p">]</span> <span class="p">],</span>
        <span class="p">[</span> <span class="mf">0.91</span><span class="p">,</span> <span class="p">[</span> <span class="s1">&#39;and&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span> <span class="p">]</span> <span class="p">]</span> <span class="p">],</span>
        <span class="nx">vars</span><span class="o">:</span> <span class="p">[</span> <span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span> <span class="p">],</span>
        <span class="nx">probs</span><span class="o">:</span> <span class="p">[</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.91</span> <span class="p">]</span> <span class="p">},</span>
    <span class="nx">vars</span><span class="o">:</span> <span class="p">[</span> <span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span> <span class="p">]</span> <span class="p">}</span>
</pre></div>
</div>
<p>Once the probability network is complete, we can use <code class="xref js js-func docutils literal notranslate"><span class="pre">prob()</span></code> to evaluate probability calculations over that network.  For example, if we want to know the probability of <cite>X or Y</cite>, we can enter the following:</p>
<div class="highlight-js notranslate"><div class="highlight"><pre><span></span><span class="nx">prob</span><span class="p">([</span><span class="nx">or</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">],</span><span class="nx">mynet</span><span class="p">)</span>

<span class="c1">// result is:</span>

<span class="mf">0.84</span>
</pre></div>
</div>
<p>The core calculator expects a formula in prefix notation and a (completed) probability network object.  It then transforms the probability formula into <em>Disjunctive Normal Form</em> and evaluates each part of the DNF formula by “completing” the variable combinations and looking up the probabilities of the variables (and multiplying and summing those).   To unpack the various parts of the above sentence:</p>
<p><em>Disjunctive Normal Form</em> means that in a logical expression, we drive negations inwards until they apply only to variables and not sub-expressions.  Then we distribute “AND” over “OR”.  We repeat that process until we have a simple list of conjunctions of either variables or their negations.  Along the way, we also resolve contradictions (i.e. cancelling out of a term and its negation) and duplications. For example, let’s say that we have the following expression: <cite>F=[or,[not,[and,’X’,[not,’Y’]]],’X’,[not,[or,’A’,[and,’B’,’C’]]]]</cite></p>
<p>After moving the negations inwards, we would have  (on the node commandline, you could produce this by <cite>distnot(F)</cite> ):</p>
<div class="highlight-js notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="s1">&#39;or&#39;</span><span class="p">,</span>
  <span class="p">[</span><span class="s1">&#39;or&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;not&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">],</span><span class="s1">&#39;Y&#39;</span><span class="p">],</span>
  <span class="s1">&#39;X&#39;</span><span class="p">,</span>
  <span class="p">[</span><span class="s1">&#39;and&#39;</span><span class="p">,</span>
    <span class="p">[</span><span class="s1">&#39;not&#39;</span><span class="p">,</span><span class="s1">&#39;A&#39;</span><span class="p">],</span>
    <span class="p">[</span><span class="s1">&#39;or&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;not&#39;</span><span class="p">,</span><span class="s1">&#39;B&#39;</span> <span class="p">],</span> <span class="p">[</span><span class="s1">&#39;not&#39;</span><span class="p">,</span><span class="s1">&#39;C&#39;</span> <span class="p">]]</span>
  <span class="p">]</span>
<span class="p">]</span>
</pre></div>
</div>
<p>At this stage, some simplification is possible, because we can remove duplicate “or” operations, and we notice that X and its negation will cancel each other out.  Moreover, we can distribute the “and” over “or” in one of the subterms.  After applying that process a few times, we end up with the ultimate simplification (on the node commandline you could produce this by <cite>dnf(F)</cite> ):</p>
<div class="highlight-js notranslate"><div class="highlight"><pre><span></span><span class="p">[</span> <span class="s1">&#39;or&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="p">[</span> <span class="s1">&#39;and&#39;</span><span class="p">,</span> <span class="p">[</span> <span class="s1">&#39;not&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span> <span class="p">],</span> <span class="p">[</span> <span class="s1">&#39;not&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span> <span class="p">]</span> <span class="p">],</span>  <span class="p">[</span> <span class="s1">&#39;and&#39;</span><span class="p">,</span> <span class="p">[</span> <span class="s1">&#39;not&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span> <span class="p">],</span> <span class="p">[</span> <span class="s1">&#39;not&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span> <span class="p">]</span> <span class="p">]</span> <span class="p">]</span>
</pre></div>
</div>
<p>If each variable represented a probability, then the probability of this logical combination would be a sum over the disjunction (i.e. the elements of the “or” list), and a product over conjunctions (i.e. multiply the elements of the “and” lists):</p>
<div class="highlight-js notranslate"><div class="highlight"><pre><span></span><span class="nx">Y</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="nx">B</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="nx">A</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="nx">C</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="nx">A</span><span class="p">)</span>
</pre></div>
</div>
<p>The way we obtain the relevant probability for each variable is to look it up in the probability network.  The calculation of probability of a DNF formula is handled by the <code class="xref js js-func docutils literal notranslate"><span class="pre">prob()</span></code> function (Note: the function will apply DNF – you do not need to apply dnf beforehand).  This probability function needs to handle a few complications.  Firstly, the possible operators in a function are <cite>not</cite>,`or`,`and` and <cite>divide</cite>.  The latter originates from the (Kolmogorov) axiomatic definition of <cite>given</cite>:  <cite>prob X given Y</cite> == <cite>prob(X and Y) / prob Y</cite>.  Note that we have taken care of supplementary definitions in the DNF resolution.  That is, <cite>X given Y</cite> is:</p>
<ul class="simple">
<li>1 (i.e. <cite>[] / []</cite>) if both X and Y resolve to <cite>[]</cite></li>
<li>0 if either, but not both, of X or Y resolves to <cite>[]</cite></li>
<li><cite>prob X / prob Y</cite> otherwise.</li>
</ul>
<p>You can try this out as follows:</p>
<div class="highlight-js notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">simple</span> <span class="o">=</span> <span class="p">{</span><span class="nx">id</span><span class="o">:</span><span class="s1">&#39;simple&#39;</span><span class="p">,</span> <span class="nx">nonp</span><span class="o">:</span><span class="p">{},</span> <span class="nx">X</span><span class="o">:</span><span class="p">{</span><span class="kc">true</span><span class="o">:</span><span class="mf">0.2</span><span class="p">},</span> <span class="nx">Y</span><span class="o">:</span><span class="p">{</span><span class="kc">true</span><span class="o">:</span><span class="mf">0.8</span><span class="p">}}</span>
<span class="nx">dnf</span><span class="p">([</span><span class="nx">given</span><span class="p">,[</span><span class="nx">and</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">,[</span><span class="nx">not</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">]],[</span><span class="nx">and</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,[</span><span class="nx">not</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">]]])</span>

<span class="c1">// result is:</span>
<span class="p">[</span><span class="nx">divide</span><span class="p">,[],[]]</span>

<span class="nx">prob</span><span class="p">([</span><span class="nx">given</span><span class="p">,[</span><span class="nx">and</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">,[</span><span class="nx">not</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">]],[</span><span class="nx">and</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,[</span><span class="nx">not</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">]]],</span><span class="nx">s</span><span class="p">)</span>

<span class="c1">// result is:</span>
<span class="mi">1</span>
</pre></div>
</div>
<p>There is one other complications that the probability calculation needs to handle.  In the <cite>simple</cite> example above, consider the probability of <cite>[or,’X’,’Y’]</cite>. The formula is DNF, but we can’t simple look up and add the probabilities of ‘X’ and ‘Y’.  The reason is that <cite>X</cite> and <cite>Y</cite> overlap if you consider all combinations. The possibilities where <cite>X</cite> is true are <cite>X and Y</cite> and <cite>X and not Y</cite>.  The possibilities where <cite>Y</cite> is true are <cite>Y and X</cite> and <cite>Y and not X</cite>.  So, they overlap on <cite>X and Y</cite> and we need to ensure that that possibility isn’t double counted. In other words, the true sum is the probabilities of <cite>X and Y</cite> + <cite>X and not Y</cite> + <cite>not X and Y</cite>, which equals <cite>0.2 * 0.8 + 0.2 * (1-0.8) + (1-0.2)*0.8 == 0.84</cite></p>
<p>The function <code class="xref js js-func docutils literal notranslate"><span class="pre">jprobs()</span></code> takes care of avoiding duplications in the probability calculation.  It does this pretty much as we would do it naturally: it expands variables in each term of the disjunctive list and marks every combination as “used” in a bitarray, while adding up the probabilities of terms.  The bitarray is simply a true/false value (i.e. “used” or “not used”), indexed by the logical combination of possible variables.  So, ‘not X and not Y’ would be index 0, ‘not X and Y’ would be index 1, ‘X and not Y1 would be index 2, and <cite>X and Y</cite> would be index 3.  We always use “binary count order” of the variables, where the variables themselves are in alphabetical order. The helper function of <code class="xref js js-func docutils literal notranslate"><span class="pre">allvars()</span></code> expands a term to cover all possible combinations of variables.  Further helper functions of <code class="xref js js-func docutils literal notranslate"><span class="pre">vars2x()</span></code> and <code class="xref js js-func docutils literal notranslate"><span class="pre">x2v()</span></code> convert variable combinations to index values and vice versa.</p>
</div>
</div>
</div>
<div class="section" id="indices-and-tables">
<h1>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></li>
<li><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></li>
<li><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></li>
</ul>
<div class="section" id="the-main-interface-to-the-probability-calculator">
<h2>The main interface to the probability calculator<a class="headerlink" href="#the-main-interface-to-the-probability-calculator" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="calcvars">
<code class="descname">calcvars</code><span class="sig-paren">(</span><em>Content</em><span class="sig-paren">)</span><a class="headerlink" href="#calcvars" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the text in Content, and calculate all the formulas in backticks in the content. Return the text, but now with the formulas (and possible results) in &lt;code&gt;…&lt;/code&gt; tags.</p>
<p>Broadly, calcvars first uses <a class="reference internal" href="#tickconvert" title="tickconvert"><code class="xref js js-func docutils literal notranslate"><span class="pre">tickconvert()</span></code></a> to convert the formulas in backticks to tagged formulas, as well as extract a formula list.  Then, it sorts the formulas in order of dependencies (of variables).  The third step is to actually interpret the formulas and store the results in an object called Rlist.  Lastly, we process the Rlist and plug any results from the formulas into the appropriate place in the html text (the right place was previously placemarked by tickconvert.  Basically, it created a tag called &lt;fi&gt; for every formula, numbered i, where the result should go). After placing the results, we return the resulting html string.</p>
<p>Calcvars is a “top level” function that you can play with from the node commandline.  So, start node and <cite>.load pcalc.js</cite>. Then, try <cite>calcvars(“&lt;p&gt;`probability of Y given X is 50%`&lt;/p&gt;&lt;p&gt;`probability of X is 50%`&lt;/p&gt;&lt;p&gt;So, the `%probability of Y?`&lt;/p&gt;”)</cite>. The result will be a string with html text, where the backticks have been replaced by html <cite>&lt;code&gt;</cite> tags, including <cite>&lt;span&gt;</cite> tags for formulas and results.  The formula and result classes have a suffix of ‘A’, ‘B’ or ‘C’. These indicate respectively whether the formula is an “assignment” (i.e. has an “=” or the keyword “is”), or a formula that needs hiding as soon as a result is available, or a formula that needs display together with the result.  Having different class names for each of these cases makes it easy to control the display with stylesheets.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>Content</strong> (<em>string</em>) – text as html string, which may contain calculator formulas inside backticks</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>string</strong> – same content is returned, but now formulas are marked up inside &lt;code&gt;…&lt;/code&gt; tags, including possible results</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="calcs">
<code class="descname">calcs</code><span class="sig-paren">(</span><em>fs</em>, <em>Net</em><span class="sig-paren">)</span><a class="headerlink" href="#calcs" title="Permalink to this definition">¶</a></dt>
<dd><p>Process a (sorted) list of formulas of the structure <cite>[[h,fid,formula]…]</cite>, where <cite>h</cite> is the sort key (variable dependency “height”), <cite>fid</cite> is the formula identifier of the form <cite>f01</cite>, and <cite>formula</cite> is a string with the formula text in the pcalc syntax.</p>
<p>The sorted list will have two major groups of probability formulas: assignments and calculations.  Assignments are processed first and used to build the equivalent of a Bayes network.  This network is then “completed” using <code class="xref js js-func docutils literal notranslate"><span class="pre">completor()</span></code>. Among other things, the completor function checks if any conditional variable has an incomplete set of conditions, in which case it uses a “noisy-or” procedure to complete the conditions.  The completor function also makes a list of variables that each conditional variable depends on, and binary-count ordered probabilities for all combinations of those variables.  All this is stored in the Net object, whose reference was passed into the calcs function.   When the Net object is complete, the calcs function will calculate the results of the remaining calculation functions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>fs</strong> (<em>array</em>) – sorted list of formulas</li>
<li><strong>Net</strong> (<em>object</em>) – a probability network object, for example <cite>{“id”:”mynet”, nonp:{}, “X”:{true:0.5}, “Y”:[[0.6, “X”],[0.2, [not,”X”]]] }</cite></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>object</strong> – the calcs result is an object with formula ids as keys and the formula result as value – only for formulas that actually have results. result structure: <cite>{‘f0’:res0, ‘f1’:res1,…}</cite></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="tickconvert">
<code class="descname">tickconvert</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#tickconvert" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a text (html) string with formulas in backticks, to a text (html) string where formulas are in code,span formulas, and span result tags</p>
<p>Note 1: the function processes a text string character-by-character from the last character to the first.  It does this, because it is easier to identify create the starting html tags (e.g. code etc.) if you already have the formula contents.  However, this means that creating “types” for the result tags is a separate step, because trying to do it in the same (major) loop can result in an error where the type from a prior formula gets attached to the the result tag.</p>
<p>The code structure for the formulas is as follows:</p>
<blockquote>
<div><ul class="simple">
<li>the <cite>&lt;code&gt;</cite> tag has a class of “pcalc”</li>
<li>the formula is wrapped in a <cite>&lt;span&gt;</cite> tag with a class of “formulaA”, “formulaB” or “formulaC”. The “A” suffix is used for assignment formulas, for example <cite>pr X = 50%</cite>.  The “B” suffix is used for calculation formulas that do not have a question mark at the end, for example <cite>pr X</cite>.  The “C” suffix is used for calculation formulas that _do_ have a question mark at the end, for example <cite>pr X?</cite>.  These suffixes enable the users to indicate whether they want a calculation to show the formula together with the result (option C), or to hide the formula and only show the result (option B).  Assignment formulas (option A) are always shown.  Having these options encoded as class types enables us to control the display via CSS.</li>
<li>the result is wrapped in a <cite>&lt;span&gt;</cite> tag with a class of “resultA”, “resultB” or “resultC”, with the same meaning as the formula tags</li>
</ul>
</div></blockquote>
<p>Note 2: we do a minimal check for having an even number of backticks.  An uneven one means that there is a backtick missing.</p>
<p>Note 3: backticks can be escaped in the source text in the usual way – prefix the backtick with a backslash</p>
<p>Note 4: part of the reason for using regex to do the transformation is so that we do not rely on DOM processing.  This avoids possible cross site scripting malware, and also makes the pcalc module more independent from any IO interfacing.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<em>string</em>) – the (html) text string that contains formulas in backticks</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>string</strong> – the html string where formulas are now inside <cite>&lt;code&gt;</cite> and <cite>&lt;span&gt;</cite> tags</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="sortfs">
<code class="descname">sortfs</code><span class="sig-paren">(</span><em>Fs</em><span class="sig-paren">)</span><a class="headerlink" href="#sortfs" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort formulas in order of maximum “height” of variables. Given an object  <cite>Fs={ ‘f1’:{‘F’:’prob X=0.5’}, ‘f2’:{‘F’: ‘prob Y=0.5’}…}</cite> return <cite>[[height,fid,F]…</cite></p>
<p>The “height” is the recursively calculated length of dependent variables that appear in the conditions that a variable depends on.  A simple definition like <cite>pr X=0.5</cite> means that the variable X does not depend on any  other variable, and so has a length of zero.  In <cite>pr Y given X=0.5</cite>, the variable Y depends on X, and so has a length of 1.  In <cite>pr Z given X or Y = 0.7</cite>, the variable Z depends on X and Y, of which Y has the longer dependency length, and so Z has a length of one more than Y (i.e. length of Z = 2).  Formulas that are not assignments, but simple calculations are given an arbitrarily long  length (1000) so that they come last in the sort order.  That is because calculations need to be performed after all assignments have been evaluated.</p>
<p>Along the way, the sort function also creates a global object called <a class="reference internal" href="#Dlist" title="Dlist"><code class="xref js js-func docutils literal notranslate"><span class="pre">Dlist()</span></code></a>, which contains a dependency list for each variable.  For example, {‘X’:null, ‘Y’:[‘X’], ‘Z’:[‘X’,’Y’]}.   The object is global and exported, in order to support external modules such as the diagram generator.  Internally, the sort routine uses Sets to update the Dlist (to avoid appending duplicate variables), but later converts the Dlist back to a simple object.</p>
<p>The relationship between Dlist and sorting the formulas is that a formula height is the height of its highest variable (as with the X,Y,Z example above).  So, first we need to calculate the height of each variable in a formula, and then determine the highest of those variables.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>Fs</strong> (<em>object</em>) – object that contains formulas</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>array</strong> – result is a sorted array of formulas <cite>[[h,fid,formula]…]</cite>, with an integer (h) “variable dependency height” as the sorting key</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="height">
<code class="descname">height</code><span class="sig-paren">(</span><em>node</em>, <em>D</em>, <em>curpath</em><span class="sig-paren">)</span><a class="headerlink" href="#height" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a node name (key) and a simple dependency structure (D), recursively calculate the dependency length for the node. Keep track which nodes have already been visited (curpath), because we don’t want to get stuck in infinite loops.  As a result, the dependency structure is treated as an acyclic graph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>node</strong> (<em>string</em>) – the node in the graph for which we want to calculate the “height”</li>
<li><strong>D</strong> (<em>object</em>) – a simple dependency structure, e.g. {‘X’:null, ‘Y’:[‘X’], ‘Z’:[‘X’,’Y’]}</li>
<li><strong>curpath</strong> (<em>array</em>) – a list of already visited nodes</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>integer</strong> – integer that represents the dependency “height”, where 0 is “no dependencies”</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Dlist">
<code class="descname">Dlist</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Dlist" title="Permalink to this definition">¶</a></dt>
<dd><p>The externally exposed object Dlist provides a simple dependency structure for variables in a probability network. For example, if Dlist contains the following: {‘X’:null,’Y’:[‘X’],’Z’:[‘X’,’Y’]}, then this represents that variable X has no dependencies, that Y depends on X and that Z depends on both X and Y.</p>
</dd></dl>

<dl class="function">
<dt id="resetcode">
<code class="descname">resetcode</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#resetcode" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove html formatting of formulas and results, and put formulas back inside backticks</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<em>string</em>) – a text string with formulas inside &lt;code&gt; tags</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>string</strong> – a string where the code and span tags are removed (including any results) and formulas are inside backticks</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="highlight">
<code class="descname">highlight</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#highlight" title="Permalink to this definition">¶</a></dt>
<dd><p>A helper function for highlight results, if the editor/webpage itself doesn’t already take care of such highlighting</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<em>string</em>) – html string with formulas already inside &lt;code&gt; tags</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>string</strong> – - same html string, but with “highlight” styling added to the resultB classes (results where the formula does not display)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="the-calculator-formula-interpreter">
<h2>The calculator formula interpreter<a class="headerlink" href="#the-calculator-formula-interpreter" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pcalc">
<code class="descname">pcalc</code><span class="sig-paren">(</span><em>S</em>, <em>U</em><span class="sig-paren">)</span><a class="headerlink" href="#pcalc" title="Permalink to this definition">¶</a></dt>
<dd><p>The top level interface to the formula interpreter. Interpret the formula in the context of the referenced probability network. Probability assignment formulas will update the network.  For example, a formula like ‘pr X is 50%` will create (or update) the network U with <cite>U[“X”] = {true: 0.5}</cite>.  Since <cite>U</cite> is an object passed by reference, the original network is updated.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first last simple">
<li><strong>S</strong> (<em>string</em>) – a text string with single formula to interpret</li>
<li><strong>U</strong> (<em>object</em>) – the structure (object passed by reference) to hold the probability network</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="tokenise">
<code class="descname">tokenise</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#tokenise" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove whitespace, separate tokens, numbers and symbols. Aside from symbols like asterisk, plus sign, etc., the tokeniser separates out “tokens” which start with a letter and are followed by letters, digits or an underscore.  These tokens are later interpreted as function names or variables.</p>
<p>Example: <cite>tokenise(‘pr Y given X is 50%’)</cite> on the node commandline will result in <cite>[ ‘pr’, ‘Y’, ‘given’, ‘X’, ‘is’, 50, ‘%’ ]</cite></p>
<p>Note 1: We pre-calculate numbers, including negative numbers. So, the minus sign in front of a number turns the number into a negative number.</p>
<p>Note 2: question mark is counted as space. This is used by the html interface (see <a class="reference internal" href="#calcs" title="calcs"><code class="xref js js-func docutils literal notranslate"><span class="pre">calcs()</span></code></a>) as a placemarker to decide whether to display the formula together with the result.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<em>string</em>) – the formula in text</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>array</strong> – a list of tokens, numbers and symbols</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pcalctok">
<code class="descname">pcalctok</code><span class="sig-paren">(</span><em>s</em>, <em>U</em><span class="sig-paren">)</span><a class="headerlink" href="#pcalctok" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret the tokens of a probability formula and possibly update the user object that contains probability variables and their values and conditions. This function is essentially the start of a recursive descent interpreter for probability math formulas.  You can see in this function that formulas are either “definitions” or “expressions”.  In other words, the grammar in this function is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pcalctok</span> <span class="o">--&gt;</span> <span class="n">definition</span> <span class="o">|</span> <span class="n">expression</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first last simple">
<li><strong>s</strong> (<em>array</em>) – array of tokens to interpret</li>
<li><strong>U</strong> (<em>object</em>) – “User space” object that contains variables, especially probability variables and their values and conditions.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="definition">
<code class="descname">definition</code><span class="sig-paren">(</span><em>s</em>, <em>U</em><span class="sig-paren">)</span><a class="headerlink" href="#definition" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret a “definition” (i.e. assignment) formula and update the user space if needed with any new variables</p>
<p>A definition can be either a simple probability definition, a conditional probability definition, or a non-probability variable assignment. So, the grammar for a definition is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">definition</span> <span class="o">--&gt;</span> <span class="n">probf</span><span class="p">,</span> <span class="p">(</span><span class="n">pdef_simple</span> <span class="o">|</span> <span class="n">pdef_given</span><span class="p">)</span>
             <span class="o">|</span> <span class="n">vardef</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first last simple">
<li><strong>s</strong> (<em>array</em>) – list (array) of tokens to interpret</li>
<li><strong>U</strong> (<em>object</em>) – “User space” object that contains variables, especially probability variables and their values and conditions.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="vardef">
<code class="descname">vardef</code><span class="sig-paren">(</span><em>s</em>, <em>U</em><span class="sig-paren">)</span><a class="headerlink" href="#vardef" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret a non-probability variable definition (i.e. assignment)</p>
<p>grammar:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vardef</span> <span class="o">--&gt;</span> <span class="n">vname</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;=&quot;</span> <span class="o">|</span> <span class="s2">&quot;is&quot;</span><span class="p">),</span> <span class="n">expression</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first last simple">
<li><strong>s</strong> (<em>array</em>) – list (array) of tokens to interpret</li>
<li><strong>U</strong> (<em>object</em>) – “User space” object that contains variables, especially probability variables and their values and conditions.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="probf">
<code class="descname">probf</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#probf" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret the probability functor (i.e. keyword that signals the start of a probability formula). No user space needs to be passed to this interpretation, because we don’t update the userspace upon seeing this keyword.  It simply acts as a signal in the processing of a formula.</p>
<p>grammar:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">probf</span> <span class="o">--&gt;</span> <span class="p">(</span><span class="s2">&quot;probability of&quot;</span> <span class="o">|</span> <span class="s2">&quot;chance of&quot;</span> <span class="o">|</span> <span class="s2">&quot;chance&quot;</span> <span class="o">|</span> <span class="s2">&quot;probability&quot;</span> <span class="o">|</span> <span class="s2">&quot;prob&quot;</span> <span class="o">|</span> <span class="s2">&quot;pr&quot;</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first last simple">
<li><strong>s</strong> (<em>array</em>) – list (array) of tokens to interpret</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pdef_simple">
<code class="descname">pdef_simple</code><span class="sig-paren">(</span><em>s</em>, <em>U</em><span class="sig-paren">)</span><a class="headerlink" href="#pdef_simple" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret simple probability definitions (after the <cite>prob</cite> keyword), like <cite>X=50%</cite></p>
<p>grammar:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pdef_simple</span> <span class="o">--&gt;</span> <span class="n">pvname</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;=&quot;</span> <span class="o">|</span> <span class="s2">&quot;is&quot;</span><span class="p">),</span> <span class="n">expression</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<em>array</em>) – list (array) of tokens to interpret</li>
<li><strong>U</strong> (<em>object</em>) – user space object where variable definitions are stored</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>object</strong> – interpreter result object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pdef_given">
<code class="descname">pdef_given</code><span class="sig-paren">(</span><em>s</em>, <em>U</em><span class="sig-paren">)</span><a class="headerlink" href="#pdef_given" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret conditional probability definitions (after the <cite>prob</cite> keyword), like <cite>X given Y=50%</cite></p>
<p>grammar:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pdef_simple</span> <span class="o">--&gt;</span> <span class="n">pargiven</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;=&quot;</span> <span class="o">|</span> <span class="s2">&quot;is&quot;</span><span class="p">),</span> <span class="n">expression</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<em>array</em>) – list (array) of tokens to interpret</li>
<li><strong>U</strong> (<em>object</em>) – user space object where variable definitions are stored</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>object</strong> – interpreter result object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pargiven">
<code class="descname">pargiven</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#pargiven" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret conditional probability variable that comes before the condition (i.e. before “given”). Pargiven takes care of the parentheses that may wrap the conditional part, for example in <cite>pr(X given Y)=0.5</cite></p>
<p>grammar:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pargiven</span> <span class="o">--&gt;</span> <span class="s2">&quot;(&quot;</span> <span class="n">pargiven</span> <span class="s2">&quot;)&quot;</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<em>array</em>) – list (array) of tokens to interpret</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>object</strong> – interpreter result object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pgiven">
<code class="descname">pgiven</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#pgiven" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret conditional probability variable that comes before the condition (i.e. before “given”).</p>
<p>grammar:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pgiven</span> <span class="o">--&gt;</span> <span class="n">vname</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;:&quot;</span> <span class="o">|</span> <span class="s2">&quot;given&quot;</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<em>array</em>) – list (array) of tokens to interpret</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>object</strong> – interpreter result object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pvname">
<code class="descname">pvname</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#pvname" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret a probability variable that may be wrapped in parentheses, as in <cite>pr(X)=0.5</cite></p>
<p>grammar:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pvname</span> <span class="o">--&gt;</span> <span class="s2">&quot;(&quot;</span> <span class="n">pvname</span> <span class="s2">&quot;)&quot;</span> <span class="o">|</span> <span class="n">vname</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<em>array</em>) – list (array) of tokens to interpret</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>object</strong> – interpreter result object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="vname">
<code class="descname">vname</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#vname" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret a variable name</p>
<p>grammar:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vname</span> <span class="o">--&gt;</span> <span class="n">pvname</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<em>array</em>) – list (array) of tokens to interpret</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>object</strong> – interpreter result object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="expression">
<code class="descname">expression</code><span class="sig-paren">(</span><em>s</em>, <em>V</em>, <em>U</em><span class="sig-paren">)</span><a class="headerlink" href="#expression" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret an arithmetic expression, including functions of numbers, of which probability functions are are one type.</p>
<p>grammar:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">expression</span> <span class="o">-&gt;</span> <span class="n">term</span> <span class="n">asop</span> <span class="o">|</span> <span class="n">asop</span>
<span class="n">term</span> <span class="o">-&gt;</span> <span class="n">factor</span> <span class="n">emdop</span>
<span class="n">factor</span> <span class="o">-&gt;</span> <span class="s2">&quot;(&quot;</span> <span class="n">expression</span> <span class="s2">&quot;)&quot;</span> <span class="o">|</span> <span class="n">FUNC</span>
<span class="n">asop</span> <span class="o">-&gt;</span> <span class="s2">&quot;+&quot;</span> <span class="n">term</span> <span class="n">asop</span> <span class="o">|</span> <span class="s2">&quot;-&quot;</span> <span class="n">term</span> <span class="n">asop</span> <span class="o">|</span> <span class="n">EMPTY</span>
<span class="n">emdop</span> <span class="o">-&gt;</span> <span class="s2">&quot;^&quot;</span> <span class="n">factor</span> <span class="n">emdop</span> <span class="o">|</span> <span class="s2">&quot;*&quot;</span> <span class="n">factor</span> <span class="n">emdop</span> <span class="o">|</span> <span class="s2">&quot;/&quot;</span> <span class="n">factor</span> <span class="n">emdop</span> <span class="o">|</span> <span class="n">EMPTY</span>
</pre></div>
</div>
<p>Note-1: some parts of an expression may be empty, like the “add or subtract” operator part.  That means the return value parameter “err” has a special value (-1) which signals a non-error empty return.  In practice, this means that the return of “errors” for the purpose of notifying users of “expectations” in the expression is not very applicable, because it is hard to decide between an expected symbol and a legitimate empty return.</p>
<p>Note-2: the FUNC factor encapsulates functions of numbers, of which the sub-grammar of probability functions is one type. So, you could comment out the probability function part in <a class="reference internal" href="#func" title="func"><code class="xref js js-func docutils literal notranslate"><span class="pre">func()</span></code></a> and have just an arithmetic interpreter.</p>
<p>Note-3: the structure of each of these interpreter functions is to test whether the next elements of the token stream (i.e. parameter “s”) matches some expected token(s) and if so, return with a value.  If it doesn’t match, then code drops to the next section of the function to try something else.  So, each test consists only of an if…return.  There is usually no explicit “…else “, just a “continue to the next lines of code if the test was unsuccessful”.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<em>array</em>) – list (array) of tokens to interpret</li>
<li><strong>V</strong> (<em>*</em>) – current value in the recursive interpretation of an expression.  May be array or number</li>
<li><strong>U</strong> (<em>object</em>) – user space object where variable definitions are stored</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>object</strong> – interpreter result object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="term">
<code class="descname">term</code><span class="sig-paren">(</span><em>s</em>, <em>V</em>, <em>U</em><span class="sig-paren">)</span><a class="headerlink" href="#term" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret an arithmetic term</p>
<p>grammar (see also the full grammar of arithmetic expressions):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">term</span> <span class="o">-&gt;</span> <span class="n">factor</span> <span class="n">emdop</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<em>array</em>) – list (array) of tokens to interpret</li>
<li><strong>V</strong> (<em>*</em>) – current value in the recursive interpretation of an expression.  May be array or number</li>
<li><strong>U</strong> (<em>object</em>) – user space object where variable definitions are stored</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>object</strong> – interpreter result object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="factor">
<code class="descname">factor</code><span class="sig-paren">(</span><em>s</em>, <em>V</em>, <em>U</em><span class="sig-paren">)</span><a class="headerlink" href="#factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret an arithmetic factor</p>
<p>grammar (see also the full grammar of arithmetic expressions):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">factor</span> <span class="o">-&gt;</span> <span class="s2">&quot;(&quot;</span> <span class="n">expression</span> <span class="s2">&quot;)&quot;</span> <span class="o">|</span> <span class="n">FUNC</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<em>array</em>) – list (array) of tokens to interpret</li>
<li><strong>V</strong> (<em>*</em>) – current value in the recursive interpretation of an expression.  May be array or number</li>
<li><strong>U</strong> (<em>object</em>) – user space object where variable definitions are stored</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>object</strong> – interpreter result object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="asop">
<code class="descname">asop</code><span class="sig-paren">(</span><em>s</em>, <em>V</em>, <em>U</em><span class="sig-paren">)</span><a class="headerlink" href="#asop" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret an arithmetic “add or subtract” subterm</p>
<p>grammar (see also the full grammar of arithmetic expressions):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">asop</span> <span class="o">-&gt;</span> <span class="s2">&quot;+&quot;</span> <span class="n">term</span> <span class="n">asop</span> <span class="o">|</span> <span class="s2">&quot;-&quot;</span> <span class="n">term</span> <span class="n">asop</span> <span class="o">|</span> <span class="n">EMPTY</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<em>array</em>) – list (array) of tokens to interpret</li>
<li><strong>V</strong> (<em>*</em>) – current value in the recursive interpretation of an expression.  May be array or number</li>
<li><strong>U</strong> (<em>object</em>) – user space object where variable definitions are stored</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>object</strong> – interpreter result object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="emdop">
<code class="descname">emdop</code><span class="sig-paren">(</span><em>s</em>, <em>value</em>, <em>U</em><span class="sig-paren">)</span><a class="headerlink" href="#emdop" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret an “exponentiation, multiply or divide” subterm</p>
<p>grammar (see also the full grammar of arithmetic expressions):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">emdop</span> <span class="o">-&gt;</span> <span class="s2">&quot;^&quot;</span> <span class="n">factor</span> <span class="n">emdop</span> <span class="o">|</span> <span class="s2">&quot;*&quot;</span> <span class="n">factor</span> <span class="n">emdop</span> <span class="o">|</span> <span class="s2">&quot;/&quot;</span> <span class="n">factor</span> <span class="n">emdop</span> <span class="o">|</span> <span class="n">EMPTY</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<em>array</em>) – list (array) of tokens to interpret</li>
<li><strong>value</strong> (<em>*</em>) – current value in the recursive interpretation of an expression.  May be array or number</li>
<li><strong>U</strong> (<em>object</em>) – user space object where variable definitions are stored</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>object</strong> – interpreter result object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="token">
<code class="descname">token</code><span class="sig-paren">(</span><em>s</em>, <em>toks</em><span class="sig-paren">)</span><a class="headerlink" href="#token" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret a token (non-variable symbol) in an arithmetic expression.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<em>array</em>) – list (array) of tokens to interpret</li>
<li><strong>toks</strong> (<em>array</em>) – the list of strings that token has to be in, in order to be considered a valid token</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>object</strong> – interpreter result object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="func">
<code class="descname">func</code><span class="sig-paren">(</span><em>s</em>, <em>U</em><span class="sig-paren">)</span><a class="headerlink" href="#func" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret a function term</p>
<p>grammar (see also the full grammar of arithmetic expressions):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">func</span> <span class="o">--&gt;</span> <span class="s2">&quot;round&quot;</span> <span class="o">|</span> <span class="s2">&quot;rounded&quot;</span>
        <span class="o">|</span> <span class="s2">&quot;percent&quot;</span> <span class="o">|</span> <span class="s2">&quot;%&quot;</span>
        <span class="o">|</span> <span class="n">number</span>
        <span class="o">|</span> <span class="n">probf</span><span class="p">,</span> <span class="n">pexpression</span>
        <span class="o">|</span> <span class="n">vname</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<em>array</em>) – list (array) of tokens to interpret</li>
<li><strong>U</strong> (<em>object</em>) – user space object where variable definitions are stored</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>object</strong> – interpreter result object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="number">
<code class="descname">number</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#number" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret a number</p>
<p>grammar (see also the full grammar of arithmetic expressions):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">number</span> <span class="o">--&gt;</span> <span class="n">NUMBER</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;%&quot;</span><span class="p">]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<em>array</em>) – list (array) of tokens to interpret</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>object</strong> – interpreter result object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pexpression">
<code class="descname">pexpression</code><span class="sig-paren">(</span><em>s</em>, <em>U</em><span class="sig-paren">)</span><a class="headerlink" href="#pexpression" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret probability expressions, which appear after signalling a probability statement in the main arithmetic grammar as a function (see above), or may appear recursively in conditional probability expressions (e.g. after the “given” keyword).</p>
<p>grammar (see also the full grammar of arithmetic expressions):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>pexpression -&gt; pexp | vpargiven      // evaluation only happens here
pexp -&gt; pterm poperation
pterm -&gt; &quot;-&quot; pterm | plogic
plogic -&gt; &quot;(&quot; pterm &quot;)&quot; | vname
poperation -&gt; &quot;&amp;&quot; pexp | &quot;|&quot; pexp | EMPTY
vpargiven -&gt; &quot;(&quot; vpargiven &quot;)&quot; | vgiven
vgiven -&gt; pexp (&quot;:&quot; | &quot;given&quot;) pexp

Note: evaluation of a probability expression only happens at the &quot;top level&quot; (in pexp or vpargiven).  At this point we call :func:`prob` to evaluate the expression in the context of the user space object that defines the probability variables (and network of dependencies -- i.e. the Bayesnet).  The remainder of the grammar is actually only parsing the probability expresssion.
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<em>array</em>) – list (array) of tokens to interpret</li>
<li><strong>U</strong> (<em>object</em>) – user space object where variable definitions are stored</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>object</strong> – interpreter result object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="vpargiven">
<code class="descname">vpargiven</code><span class="sig-paren">(</span><em>s</em>, <em>value</em>, <em>U</em><span class="sig-paren">)</span><a class="headerlink" href="#vpargiven" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret conditional variables in probability expressions, which is really <a class="reference internal" href="#vgiven" title="vgiven"><code class="xref js js-func docutils literal notranslate"><span class="pre">vgiven()</span></code></a> but possibly wrapped in parentheses.</p>
<p>grammar (see also the full grammar of probability expressions):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vpargiven</span> <span class="o">-&gt;</span> <span class="s2">&quot;(&quot;</span> <span class="n">vpargiven</span> <span class="s2">&quot;)&quot;</span> <span class="o">|</span> <span class="n">vgiven</span>
</pre></div>
</div>
<p>Note that this mirrors <a class="reference internal" href="#pargiven" title="pargiven"><code class="xref js js-func docutils literal notranslate"><span class="pre">pargiven()</span></code></a> in conditional probability assignments, but is kept separate to avoid unintended cross-overs in the interpretation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<em>array</em>) – list (array) of tokens to interpret</li>
<li><strong>value</strong> (<em>*</em>) – current value in the recursive interpretation of an expression.  May be array or number</li>
<li><strong>U</strong> (<em>object</em>) – user space object where variable definitions are stored</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>object</strong> – interpreter result object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="vgiven">
<code class="descname">vgiven</code><span class="sig-paren">(</span><em>s</em>, <em>value</em>, <em>U</em><span class="sig-paren">)</span><a class="headerlink" href="#vgiven" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret conditional variables in probability expressions.</p>
<p>grammar (see also the full grammar of probability expressions):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>vgiven -&gt; &quot;(&quot; vpargiven &quot;)&quot; | vgiven

Note that this mirrors :func:`pgiven` in conditional probability assignments, but is kept separate to avoid unintended cross-overs in the interpretation.
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<em>array</em>) – list (array) of tokens to interpret</li>
<li><strong>value</strong> (<em>*</em>) – current value in the recursive interpretation of an expression.  May be array or number</li>
<li><strong>U</strong> (<em>object</em>) – user space object where variable definitions are stored</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>object</strong> – interpreter result object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pexp">
<code class="descname">pexp</code><span class="sig-paren">(</span><em>s</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#pexp" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret a non-assignment probability expressions</p>
<p>grammar (see also the full grammar of probability expressions):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pexp</span> <span class="o">-&gt;</span> <span class="n">pterm</span> <span class="n">poperation</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<em>array</em>) – list (array) of tokens to interpret</li>
<li><strong>value</strong> (<em>*</em>) – current value in the recursive interpretation of an expression.  May be array or number</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>object</strong> – interpreter result object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pterm">
<code class="descname">pterm</code><span class="sig-paren">(</span><em>s</em>, <em>value</em>, <em>U</em><span class="sig-paren">)</span><a class="headerlink" href="#pterm" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret probability term</p>
<p>grammar (see also the full grammar of probability expressions):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pterm</span> <span class="o">-&gt;</span> <span class="s2">&quot;-&quot;</span> <span class="n">pterm</span> <span class="o">|</span> <span class="n">plogic</span>
</pre></div>
</div>
<p>Note that this mirrors <a class="reference internal" href="#pargiven" title="pargiven"><code class="xref js js-func docutils literal notranslate"><span class="pre">pargiven()</span></code></a> in conditional probability assignments, but is kept separate to avoid unintended cross-overs in the interpretation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<em>array</em>) – list (array) of tokens to interpret</li>
<li><strong>value</strong> (<em>*</em>) – current value in the recursive interpretation of an expression.  May be array or number</li>
<li><strong>U</strong> (<em>object</em>) – user space object where variable definitions are stored</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>object</strong> – interpreter result object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="plogic">
<code class="descname">plogic</code><span class="sig-paren">(</span><em>s</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#plogic" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret a logic expression in a probability expression</p>
<p>grammar (see also the full grammar of probability expressions):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">plogic</span> <span class="o">-&gt;</span> <span class="s2">&quot;(&quot;</span> <span class="n">pterm</span> <span class="s2">&quot;)&quot;</span> <span class="o">|</span> <span class="n">vname</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<em>array</em>) – list (array) of tokens to interpret</li>
<li><strong>value</strong> (<em>*</em>) – current value in the recursive interpretation of an expression.  May be array or number</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>object</strong> – interpreter result object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="poperation">
<code class="descname">poperation</code><span class="sig-paren">(</span><em>s</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#poperation" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret a logical operation as a sub expression of probability logic</p>
<p>grammar (see also the full grammar of probability expressions):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">poperation</span> <span class="o">-&gt;</span> <span class="s2">&quot;&amp;&quot;</span> <span class="n">pexp</span> <span class="o">|</span> <span class="s2">&quot;|&quot;</span> <span class="n">pexp</span> <span class="o">|</span> <span class="n">EMPTY</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<em>array</em>) – list (array) of tokens to interpret</li>
<li><strong>value</strong> (<em>*</em>) – current value in the recursive interpretation of an expression.  May be array or number</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>object</strong> – interpreter result object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="the-core-probability-calculator">
<h2>The core probability calculator<a class="headerlink" href="#the-core-probability-calculator" title="Permalink to this headline">¶</a></h2>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="#">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Welcome to pcalc’s source code documentation!</a><ul>
<li><a class="reference internal" href="#overview">Overview</a><ul>
<li><a class="reference internal" href="#overview-of-the-interpreter-sub-module">Overview of the interpreter sub-module</a></li>
<li><a class="reference internal" href="#overview-of-the-probability-calculator-sub-module">Overview of the probability calculator sub-module</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#indices-and-tables">Indices and tables</a><ul>
<li><a class="reference internal" href="#the-main-interface-to-the-probability-calculator">The main interface to the probability calculator</a></li>
<li><a class="reference internal" href="#the-calculator-formula-interpreter">The calculator formula interpreter</a></li>
<li><a class="reference internal" href="#the-core-probability-calculator">The core probability calculator</a></li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="#">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/index.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, Richard de Rozario.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.7.5</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.11</a>
      
      |
      <a href="_sources/index.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>