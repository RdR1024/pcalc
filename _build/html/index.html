
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Welcome to pcalc’s source code documentation! &#8212; pcalc 0.9.0 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="welcome-to-pcalc-s-source-code-documentation">
<h1>Welcome to pcalc’s source code documentation!<a class="headerlink" href="#welcome-to-pcalc-s-source-code-documentation" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
</div>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>The pcalc module (<cite>pcalc.js</cite>) is actually a pre-packaged .js file that contains three major (sub-) modules. The first is a wrapper that provides the main (html) interface to the calculator.  This interface is intended to be very loosely coupled with any actual HTML page you might have.  Your HTML page simply feeds the html content as a string to <a class="reference internal" href="#calcvars" title="calcvars"><code class="xref js js-func docutils literal notranslate"><span class="pre">calcvars()</span></code></a>, which will do the calculation of any formulas (inside backticks) in the html content and returns a modified html string for you to display.  The modified html string will have placed the formulas inside <cite>&lt;code class=”pcalc”&gt;&lt;span class=”formula.”&gt;…&lt;/span&gt;&lt;span class=”result.”&gt;…&lt;/span&gt;&lt;/code&gt;</cite> tags. You can find details on tag structure in the <a class="reference internal" href="#tickconvert" title="tickconvert"><code class="xref js js-func docutils literal notranslate"><span class="pre">tickconvert()</span></code></a> documentation.</p>
<p>The other functions in the wrapper section (i.e. <a class="reference internal" href="#calcs" title="calcs"><code class="xref js js-func docutils literal notranslate"><span class="pre">calcs()</span></code></a>, <a class="reference internal" href="#sortfs" title="sortfs"><code class="xref js js-func docutils literal notranslate"><span class="pre">sortfs()</span></code></a>, <a class="reference internal" href="#height" title="height"><code class="xref js js-func docutils literal notranslate"><span class="pre">height()</span></code></a>, <a class="reference internal" href="#tickconvert" title="tickconvert"><code class="xref js js-func docutils literal notranslate"><span class="pre">tickconvert()</span></code></a>, and <a class="reference internal" href="#highlight" title="highlight"><code class="xref js js-func docutils literal notranslate"><span class="pre">highlight()</span></code></a> ) are mainly there to support <a class="reference internal" href="#calcvars" title="calcvars"><code class="xref js js-func docutils literal notranslate"><span class="pre">calcvars()</span></code></a>.  There is also a function (i.e. <a class="reference internal" href="#resetcode" title="resetcode"><code class="xref js js-func docutils literal notranslate"><span class="pre">resetcode()</span></code></a>) that removes the <cite>&lt;code&gt;</cite> tags and calculation results and restores formulas to be inside the original backticks.  The <a class="reference internal" href="#sortfs" title="sortfs"><code class="xref js js-func docutils literal notranslate"><span class="pre">sortfs()</span></code></a> function (and its sub-function <a class="reference internal" href="#height" title="height"><code class="xref js js-func docutils literal notranslate"><span class="pre">height()</span></code></a>) are worth noting, because they put probability formulas in the right order for calculation.  With probability formulas, you have to make sure that you evaluate the formulas with conditions (i.e. dependencies on other variables) in the right order of dependency.  For example, suppose you have the following formulas:</p>
<blockquote>
<div><p><cite>pr Y given X is 50%</cite></p>
<p><cite>pr X is 20%</cite></p>
</div></blockquote>
<p>You have to evaluate the last formula first, because Y depends on having a value for X.  The <a class="reference internal" href="#sortfs" title="sortfs"><code class="xref js js-func docutils literal notranslate"><span class="pre">sortfs()</span></code></a> performs this task. One more point worth noting is that <code class="xref js js-func docutils literal notranslate"><span class="pre">sorfs()</span></code> also constructs a global object called <cite>Dlist</cite> which contains all the variables from all the formulas and has a simple dependency list for each.  For example, if the text contains the following formulas, <cite>pr X=0.5</cite>, <cite>pr Y given X = 0.2</cite> and <cite>pr Z given X or Y = 0.5</cite>, then <cite>Dlist</cite> will contain the following:</p>
<blockquote>
<div>{ “X”:null, “Y”:[“X”], “Z”:[“X”,”Y”] }</div></blockquote>
<p>The following are some examples of probability problems that you can try out (they also appear in the user guide in more expanded form). To try them, use the string as the parameter in the <a class="reference internal" href="#calcvars" title="calcvars"><code class="xref js js-func docutils literal notranslate"><span class="pre">calcvars()</span></code></a> function, for example, <cite>calcvars(WG)</cite>.</p>
<div class="highlight-js notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">WG</span> <span class="o">=</span> <span class="s2">&quot;`pr Rain=0.2` `pr Sprinkler:Rain=0.01` `pr Sprinkler:-Rain=0.4` `pr Wet:-Sprinkler,-Rain=0` `pr Wet:-Sprinkler,Rain=0.8` `pr Wet:Sprinkler,-Rain=0.9` `pr Wet:Sprinkler,Rain=0.99` `%pr Wet?` &quot;</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">Simple</span> <span class="o">=</span> <span class="s2">&quot;&lt;p&gt;`probability of Y given X is 50%`&lt;/p&gt;&lt;p&gt;`probability of X is 50%`&lt;/p&gt;&lt;p&gt;So, the `%probability of Y?`&lt;/p&gt;&quot;</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">Black</span> <span class="o">=</span> <span class="s2">&quot;`pr Plane=10%` `pr Drone=5%` `pr Intercept:Plane=85%` `pr Intercept: -Plane=10%` `pr Report: Drone=95%` `pr Report: -Drone=5%` `pr RusExpert: Plane=80%` `pr RusExpert: -Plane=40%` `pr USExpert: Drone=70%` `pr USExpert: -Drone=20%` `pr Radar:Drone=95%` `pr Radar: Plane=90%` `pr Radar: -(Plane or Drone) =0.5%` `%pr Plane: (Intercept &amp; Report &amp; Radar &amp;  -RusExpert &amp; -USExpert)`&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>The next major section starts with the function <a class="reference internal" href="#pcalc" title="pcalc"><code class="xref js js-func docutils literal notranslate"><span class="pre">pcalc()</span></code></a> and comprises the formula interpreter. This formula interpreter is called for every formula in the html content, from the function <a class="reference internal" href="#calcs" title="calcs"><code class="xref js js-func docutils literal notranslate"><span class="pre">calcs()</span></code></a> in the wrapper section.  The formula interpreter will use “assignment formulas” to update an object (typically called “U”) which ultimately contains the probability network variables and their definitions.  This object is then used later to calculate the results of formulas.  Even though <a class="reference internal" href="#pcalc" title="pcalc"><code class="xref js js-func docutils literal notranslate"><span class="pre">pcalc()</span></code></a> only interpretes one formula at the time, the <cite>U</cite> object stores or updates any variable assignments.  This way, successive calls to <a class="reference internal" href="#pcalc" title="pcalc"><code class="xref js js-func docutils literal notranslate"><span class="pre">pcalc()</span></code></a> will incrementally build the probability network in <cite>U</cite>. The wrapper section initialises <cite>U</cite>, which is by default not global.  However, for debugging, <cite>U</cite> can easily be made a global object (see the commented out lines in <a class="reference internal" href="#calcvars" title="calcvars"><code class="xref js js-func docutils literal notranslate"><span class="pre">calcvars()</span></code></a>).</p>
<div class="section" id="overview-of-the-interpreter-sub-module">
<h3>Overview of the interpreter sub-module<a class="headerlink" href="#overview-of-the-interpreter-sub-module" title="Permalink to this headline">¶</a></h3>
<p>The function <a class="reference internal" href="#pcalc" title="pcalc"><code class="xref js js-func docutils literal notranslate"><span class="pre">pcalc()</span></code></a> is essentially the start of a recursive descent interpreter that translates the formulas into a more easily computable structure, which is passed to the third major sub-module, which is the computational engine for probability networks (more on that later).  We can play with <a class="reference internal" href="#pcalc" title="pcalc"><code class="xref js js-func docutils literal notranslate"><span class="pre">pcalc()</span></code></a> from the node commandline (or the browser console), as long as we pass it a “User space” object.  An empty object can be defined on the commandline as follows:</p>
<blockquote>
<div><strong>&gt;</strong> var U = { id:”my space”, nonp:{} }</div></blockquote>
<p>We can then apply <a class="reference internal" href="#pcalc" title="pcalc"><code class="xref js js-func docutils literal notranslate"><span class="pre">pcalc()</span></code></a>, for example:</p>
<blockquote>
<div><strong>&gt;</strong> pcalc(‘pr X=50%’,U)</div></blockquote>
<p>We then see that the probability variable has been added to <cite>U</cite>:</p>
<blockquote>
<div><p><strong>&gt;</strong> U</p>
<p>// result is:</p>
<p>{ id: ‘my space’, nonp: {}, X: { true: 0.5 } }</p>
</div></blockquote>
<p>In case you’re wondering what the <cite>nonp</cite> is for:  it holds non-probabilistic variables.  For example,</p>
<blockquote>
<div><p><strong>&gt;</strong> pcalc(‘X = 3’,U)</p>
<p><strong>&gt;</strong> U</p>
<p>// result is:</p>
<p>{ id: ‘my space’, nonp: { X: 3 }, X: { true: 0.5 } }</p>
<p><strong>&gt;</strong> pcalc(‘1+2*X’,U)</p>
<p>// result is:</p>
<p>7</p>
</div></blockquote>
<p>From the examples above, it should be clear that the “wrapper” section of <cite>pcalc.js</cite> mostly extracts a list of formulas from the html content and passes each formula to <a class="reference internal" href="#pcalc" title="pcalc"><code class="xref js js-func docutils literal notranslate"><span class="pre">pcalc()</span></code></a>, together with a user space object that will hold all the probability variable definitions (as well as any non-probability variables, but we’ll ignore that for the moment).  Here is an example of how to construct a probability network from the commandline, using <a class="reference internal" href="#pcalc" title="pcalc"><code class="xref js js-func docutils literal notranslate"><span class="pre">pcalc()</span></code></a>:</p>
<div class="highlight-js notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">W</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">id</span><span class="o">:</span><span class="s2">&quot;wet grass&quot;</span><span class="p">,</span> <span class="nx">nonp</span><span class="o">:</span><span class="p">{}</span> <span class="p">}</span>
<span class="nx">pcalc</span><span class="p">(</span><span class="s2">&quot;pr Rain=20%&quot;</span><span class="p">,</span> <span class="nx">W</span><span class="p">)</span>
<span class="nx">pcalc</span><span class="p">(</span><span class="s2">&quot;pr Sprinkler given Rain=1%&quot;</span><span class="p">,</span> <span class="nx">W</span><span class="p">)</span>
<span class="nx">pcalc</span><span class="p">(</span><span class="s2">&quot;pr Sprinkler given not Rain=40%&quot;</span><span class="p">,</span> <span class="nx">W</span><span class="p">)</span>
<span class="nx">pcalc</span><span class="p">(</span><span class="s2">&quot;pr WetGrass given not Sprinkler and not Rain = 0%&quot;</span><span class="p">,</span> <span class="nx">W</span><span class="p">)</span>
<span class="nx">pcalc</span><span class="p">(</span><span class="s2">&quot;pr WetGrass given not Sprinkler and Rain = 80%&quot;</span><span class="p">,</span> <span class="nx">W</span><span class="p">)</span>
<span class="nx">pcalc</span><span class="p">(</span><span class="s2">&quot;pr WetGrass given Sprinkler and not Rain = 90%&quot;</span><span class="p">,</span> <span class="nx">W</span><span class="p">)</span>
<span class="nx">pcalc</span><span class="p">(</span><span class="s2">&quot;pr WetGrass given Sprinkler and Rain = 99%&quot;</span><span class="p">,</span> <span class="nx">W</span><span class="p">)</span>
</pre></div>
</div>
<p>We can then inspect the probability network (i.e. Bayes net) created in <cite>W</cite>. We’ll use the <cite>print.js</cite> utility to see the unabbreviated content:</p>
<div class="highlight-js notranslate"><div class="highlight"><pre><span></span> <span class="p">.</span><span class="nx">load</span> <span class="nx">print</span><span class="p">.</span><span class="nx">js</span>
 <span class="nx">print</span><span class="p">(</span><span class="nx">W</span><span class="p">)</span>

<span class="c1">// result is:</span>

<span class="p">{</span> <span class="nx">id</span><span class="o">:</span> <span class="s1">&#39;wet grass&#39;</span><span class="p">,</span>
    <span class="nx">nonp</span><span class="o">:</span> <span class="p">{},</span>
    <span class="nx">Rain</span><span class="o">:</span> <span class="p">{</span> <span class="kc">true</span><span class="o">:</span> <span class="mf">0.2</span> <span class="p">},</span>
    <span class="nx">Sprinkler</span><span class="o">:</span> <span class="p">{</span> <span class="s1">&#39;#&#39;</span><span class="o">:</span> <span class="p">[</span> <span class="p">[</span> <span class="mf">0.01</span><span class="p">,</span> <span class="s1">&#39;Rain&#39;</span> <span class="p">],</span> <span class="p">[</span> <span class="mf">0.4</span><span class="p">,</span> <span class="p">[</span> <span class="s1">&#39;not&#39;</span><span class="p">,</span> <span class="s1">&#39;Rain&#39;</span> <span class="p">]</span> <span class="p">]</span> <span class="p">]</span> <span class="p">},</span>
    <span class="nx">WetGrass</span><span class="o">:</span>
        <span class="p">{</span> <span class="s1">&#39;#&#39;</span><span class="o">:</span>
            <span class="p">[</span> <span class="p">[</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[</span> <span class="s1">&#39;and&#39;</span><span class="p">,</span> <span class="p">[</span> <span class="s1">&#39;not&#39;</span><span class="p">,</span> <span class="s1">&#39;Sprinkler&#39;</span> <span class="p">],</span> <span class="p">[</span> <span class="s1">&#39;not&#39;</span><span class="p">,</span> <span class="s1">&#39;Rain&#39;</span> <span class="p">]</span> <span class="p">]</span> <span class="p">],</span>
            <span class="p">[</span> <span class="mf">0.8</span><span class="p">,</span> <span class="p">[</span> <span class="s1">&#39;and&#39;</span><span class="p">,</span> <span class="p">[</span> <span class="s1">&#39;not&#39;</span><span class="p">,</span> <span class="s1">&#39;Sprinkler&#39;</span> <span class="p">],</span> <span class="s1">&#39;Rain&#39;</span> <span class="p">]</span> <span class="p">],</span>
            <span class="p">[</span> <span class="mf">0.9</span><span class="p">,</span> <span class="p">[</span> <span class="s1">&#39;and&#39;</span><span class="p">,</span> <span class="s1">&#39;Sprinkler&#39;</span><span class="p">,</span> <span class="p">[</span> <span class="s1">&#39;not&#39;</span><span class="p">,</span> <span class="s1">&#39;Rain&#39;</span> <span class="p">]</span> <span class="p">]</span> <span class="p">],</span>
            <span class="p">[</span> <span class="mf">0.99</span><span class="p">,</span> <span class="p">[</span> <span class="s1">&#39;and&#39;</span><span class="p">,</span> <span class="s1">&#39;Sprinkler&#39;</span><span class="p">,</span> <span class="s1">&#39;Rain&#39;</span> <span class="p">]</span> <span class="p">]</span> <span class="p">]</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The resulting user space object is a straight-forward javascript object.  It could be created manually, or perhaps imported via JSON.  The object structure also shows much of how probability formulas are represented internally.  Essentially, the logic component of a formula is represented using operator-prefix lists.  For example, [“and”,”X”,”Y”,”Z”] represents the conjunction of X,Y and Z.  We’ll come back to that in the evaluation sub-module, but for now we’ll note that the interpreter simply translates more conventially written formulas into this internal structure.</p>
<p>Note that the <a class="reference internal" href="#pcalc" title="pcalc"><code class="xref js js-func docutils literal notranslate"><span class="pre">pcalc()</span></code></a> interpreter doesn’t only interpret probability formulas, but can handle basic arithmetic as well.  For example, try <cite>pcalc(“1+2*3”,U)</cite>.</p>
<p>The recursive descent interpreter consists of a collection of functions, each of which looks at the next token(s) in the list and decides if those tokens match what the function is looking for.  The result of each function is returned in this general structure:</p>
<div class="highlight-js notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="nx">err</span><span class="o">:</span> <span class="nx">ErrorStatus</span><span class="p">,</span> <span class="nx">val</span><span class="o">:</span> <span class="nx">ValueOfTheInterpretation</span><span class="p">,</span> <span class="nx">tail</span><span class="o">:</span> <span class="nx">RestOfTheTokens</span><span class="p">}</span>
</pre></div>
</div>
<p>The interpreter will evaluate the expressions it’s given and return a result back to the top level function (i.e. <a class="reference internal" href="#pcalc" title="pcalc"><code class="xref js js-func docutils literal notranslate"><span class="pre">pcalc()</span></code></a>).  However, the as far as probability formulas is concerned, the interpreter is a “lazy interpreter” – it waits until the last possible moment to evaluate the formula.  In fact, there are only two functions where that evaluation takes place: <a class="reference internal" href="#pexpression" title="pexpression"><code class="xref js js-func docutils literal notranslate"><span class="pre">pexpression()</span></code></a> and <a class="reference internal" href="#vgiven" title="vgiven"><code class="xref js js-func docutils literal notranslate"><span class="pre">vgiven()</span></code></a>, both of which call the function <a class="reference internal" href="#prob" title="prob"><code class="xref js js-func docutils literal notranslate"><span class="pre">prob()</span></code></a> after they get the result from the expression parser <a class="reference internal" href="#pexp" title="pexp"><code class="xref js js-func docutils literal notranslate"><span class="pre">pexp()</span></code></a>.</p>
<p>You can play around with probability formulas (the logic part) without actually evaluating them. Try the following:</p>
<div class="highlight-js notranslate"><div class="highlight"><pre><span></span><span class="nx">print</span><span class="p">(</span> <span class="nx">pexp</span><span class="p">([</span><span class="s2">&quot;X&quot;</span><span class="p">,</span><span class="nx">and</span><span class="p">,</span><span class="s2">&quot;Y&quot;</span><span class="p">,</span><span class="nx">or</span><span class="p">,</span><span class="nx">not</span><span class="p">,</span><span class="s2">&quot;Z&quot;</span><span class="p">],</span><span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="p">)</span>

<span class="c1">// result is:</span>
<span class="p">{</span> <span class="nx">err</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
  <span class="nx">val</span><span class="o">:</span> <span class="p">[</span> <span class="s1">&#39;and&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="p">[</span> <span class="s1">&#39;or&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="p">[</span> <span class="s1">&#39;not&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span> <span class="p">]</span> <span class="p">]</span> <span class="p">],</span>
  <span class="nx">tail</span><span class="o">:</span> <span class="p">[]</span> <span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="overview-of-the-probability-calculator-sub-module">
<h3>Overview of the probability calculator sub-module<a class="headerlink" href="#overview-of-the-probability-calculator-sub-module" title="Permalink to this headline">¶</a></h3>
<p>Once the interpreter has translated the probability formula into the internal operator-prefix structure, and updated the user space with the variable assignments, we can calculate probability results with the <a class="reference internal" href="#prob" title="prob"><code class="xref js js-func docutils literal notranslate"><span class="pre">prob()</span></code></a> function.  This function requires a formula in prefix notation and a user space object and returns the resulting probability.</p>
<p>Note that there is one intermediate step necessary before we can use a user space object.  That is, we need to run the <a class="reference internal" href="#completor" title="completor"><code class="xref js js-func docutils literal notranslate"><span class="pre">completor()</span></code></a> function over the user space object, to ensure that all the conditional variables in the probability network have a <em>complete</em> set of conditions.  If the conditions are only partially defined, then the <a class="reference internal" href="#completor" title="completor"><code class="xref js js-func docutils literal notranslate"><span class="pre">completor()</span></code></a> function will detect that and apply the “noisy-or” algorithm to try and complete the conditions.  The “noisy-or” algorithm essentially calculates for each combination of dependent variables the negation of the product of negated positive dependent variables.  For example, assume that we have defined the following probability network:</p>
<div class="highlight-js notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">mynet</span> <span class="o">=</span> <span class="p">{</span><span class="nx">id</span><span class="o">:</span><span class="s2">&quot;mynet&quot;</span><span class="p">,</span>
    <span class="nx">X</span><span class="o">:</span> <span class="p">{</span><span class="kc">true</span><span class="o">:</span> <span class="mf">0.2</span><span class="p">},</span>
    <span class="nx">Y</span><span class="o">:</span> <span class="p">{</span><span class="kc">true</span><span class="o">:</span> <span class="mf">0.8</span><span class="p">},</span>
    <span class="nx">Z</span><span class="o">:</span> <span class="p">{</span><span class="s2">&quot;#&quot;</span><span class="o">:</span> <span class="p">[</span>  <span class="p">[</span><span class="mf">0.9</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">]</span> <span class="p">]}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Notice that the conditions of “Z” are combinatorially incomplete.  For instance, there is no definition for the conditional probability of “Z” when “X” is true, but “Y” is false.  The function <a class="reference internal" href="#completor" title="completor"><code class="xref js js-func docutils literal notranslate"><span class="pre">completor()</span></code></a> will detect that and apply the “noisy-or” algorithm.  At the node command line (after loading pcalc.js), enter the above probability network and then try the following:</p>
<div class="highlight-js notranslate"><div class="highlight"><pre><span></span><span class="nx">completor</span><span class="p">(</span><span class="nx">mynet</span><span class="p">)</span>
<span class="nx">print</span><span class="p">(</span><span class="nx">mynet</span><span class="p">)</span>

<span class="c1">// result is (numbers rounded for readability):</span>

<span class="p">{</span>   <span class="nx">id</span><span class="o">:</span> <span class="s1">&#39;mynet&#39;</span><span class="p">,</span>
    <span class="nx">X</span><span class="o">:</span> <span class="p">{</span> <span class="kc">true</span><span class="o">:</span> <span class="mf">0.2</span> <span class="p">},</span>
    <span class="nx">Y</span><span class="o">:</span> <span class="p">{</span> <span class="kc">true</span><span class="o">:</span> <span class="mf">0.8</span> <span class="p">},</span>
    <span class="nx">Z</span><span class="o">:</span> <span class="p">{</span> <span class="s1">&#39;#&#39;</span><span class="o">:</span>
        <span class="p">[</span> <span class="p">[</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[</span> <span class="s1">&#39;and&#39;</span><span class="p">,</span> <span class="p">[</span> <span class="s1">&#39;not&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span> <span class="p">],</span> <span class="p">[</span> <span class="s1">&#39;not&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span> <span class="p">]</span> <span class="p">]</span> <span class="p">],</span>
        <span class="p">[</span> <span class="mf">0.01</span><span class="p">,</span> <span class="p">[</span> <span class="s1">&#39;and&#39;</span><span class="p">,</span> <span class="p">[</span> <span class="s1">&#39;not&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span> <span class="p">],</span> <span class="s1">&#39;Y&#39;</span> <span class="p">]</span> <span class="p">],</span>
        <span class="p">[</span> <span class="mf">0.9</span><span class="p">,</span> <span class="p">[</span> <span class="s1">&#39;and&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="p">[</span> <span class="s1">&#39;not&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span> <span class="p">]</span> <span class="p">]</span> <span class="p">],</span>
        <span class="p">[</span> <span class="mf">0.91</span><span class="p">,</span> <span class="p">[</span> <span class="s1">&#39;and&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span> <span class="p">]</span> <span class="p">]</span> <span class="p">],</span>
        <span class="nx">vars</span><span class="o">:</span> <span class="p">[</span> <span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span> <span class="p">],</span>
        <span class="nx">probs</span><span class="o">:</span> <span class="p">[</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.91</span> <span class="p">]</span> <span class="p">},</span>
    <span class="nx">vars</span><span class="o">:</span> <span class="p">[</span> <span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span> <span class="p">]</span> <span class="p">}</span>
</pre></div>
</div>
<p>Once the probability network is complete, we can use <a class="reference internal" href="#prob" title="prob"><code class="xref js js-func docutils literal notranslate"><span class="pre">prob()</span></code></a> to evaluate probability calculations over that network.  For example, if we want to know the probability of <cite>X or Y</cite>, we can enter the following:</p>
<div class="highlight-js notranslate"><div class="highlight"><pre><span></span><span class="nx">prob</span><span class="p">([</span><span class="nx">or</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">],</span><span class="nx">mynet</span><span class="p">)</span>

<span class="c1">// result is:</span>

<span class="mf">0.84</span>
</pre></div>
</div>
<p>The core calculator expects a formula in prefix notation and a (completed) probability network object.  It then transforms the probability formula into <em>Disjunctive Normal Form</em> and evaluates each part of the DNF formula by “completing” the variable combinations and looking up the probabilities of the variables (and multiplying and summing those).   To unpack the various parts of the above sentence:</p>
<p><em>Disjunctive Normal Form</em> means that in a logical expression, we drive negations inwards until they apply only to variables and not sub-expressions.  Then we distribute “AND” over “OR”.  We repeat that process until we have a simple list of conjunctions of either variables or their negations.  Along the way, we also resolve contradictions (i.e. cancelling out of a term and its negation) and duplications. For example, let’s say that we have the following expression: <cite>F=[or,[not,[and,’X’,[not,’Y’]]],’X’,[not,[or,’A’,[and,’B’,’C’]]]]</cite></p>
<p>After moving the negations inwards, we would have  (on the node commandline, you could produce this by <cite>distnot(F)</cite> ):</p>
<div class="highlight-js notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="s1">&#39;or&#39;</span><span class="p">,</span>
  <span class="p">[</span><span class="s1">&#39;or&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;not&#39;</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">],</span><span class="s1">&#39;Y&#39;</span><span class="p">],</span>
  <span class="s1">&#39;X&#39;</span><span class="p">,</span>
  <span class="p">[</span><span class="s1">&#39;and&#39;</span><span class="p">,</span>
    <span class="p">[</span><span class="s1">&#39;not&#39;</span><span class="p">,</span><span class="s1">&#39;A&#39;</span><span class="p">],</span>
    <span class="p">[</span><span class="s1">&#39;or&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;not&#39;</span><span class="p">,</span><span class="s1">&#39;B&#39;</span> <span class="p">],</span> <span class="p">[</span><span class="s1">&#39;not&#39;</span><span class="p">,</span><span class="s1">&#39;C&#39;</span> <span class="p">]]</span>
  <span class="p">]</span>
<span class="p">]</span>
</pre></div>
</div>
<p>At this stage, some simplification is possible, because we can remove duplicate “or” operations, and we notice that X and its negation will cancel each other out.  Moreover, we can distribute the “and” over “or” in one of the subterms.  After applying that process a few times, we end up with the ultimate simplification (on the node commandline you could produce this by <cite>dnf(F)</cite> ):</p>
<div class="highlight-js notranslate"><div class="highlight"><pre><span></span><span class="p">[</span> <span class="s1">&#39;or&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="p">[</span> <span class="s1">&#39;and&#39;</span><span class="p">,</span> <span class="p">[</span> <span class="s1">&#39;not&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span> <span class="p">],</span> <span class="p">[</span> <span class="s1">&#39;not&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span> <span class="p">]</span> <span class="p">],</span>  <span class="p">[</span> <span class="s1">&#39;and&#39;</span><span class="p">,</span> <span class="p">[</span> <span class="s1">&#39;not&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span> <span class="p">],</span> <span class="p">[</span> <span class="s1">&#39;not&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span> <span class="p">]</span> <span class="p">]</span> <span class="p">]</span>
</pre></div>
</div>
<p>If each variable represented a probability, then the probability of this logical combination would be a sum over the disjunction (i.e. the elements of the “or” list), and a product over conjunctions (i.e. multiply the elements of the “and” lists):</p>
<div class="highlight-js notranslate"><div class="highlight"><pre><span></span><span class="nx">Y</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="nx">B</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="nx">A</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="nx">C</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="nx">A</span><span class="p">)</span>
</pre></div>
</div>
<p>The way we obtain the relevant probability for each variable is to look it up in the probability network.  The calculation of probability of a DNF formula is handled by the <a class="reference internal" href="#prob" title="prob"><code class="xref js js-func docutils literal notranslate"><span class="pre">prob()</span></code></a> function (Note: the function will apply DNF – you do not need to apply dnf beforehand).  This probability function needs to handle a few complications.  Firstly, the possible operators in a function are <cite>not</cite>,`or`,`and` and <cite>divide</cite>.  The latter originates from the (Kolmogorov) axiomatic definition of <cite>given</cite>:  <cite>prob X given Y</cite> == <cite>prob(X and Y) / prob Y</cite>.  Note that we have taken care of supplementary definitions in the DNF resolution.  That is, <cite>X given Y</cite> is:</p>
<ul class="simple">
<li>1 (i.e. <cite>[] / []</cite>) if both X and Y resolve to <cite>[]</cite></li>
<li>0 if either, but not both, of X or Y resolves to <cite>[]</cite></li>
<li><cite>prob X / prob Y</cite> otherwise.</li>
</ul>
<p>You can try this out as follows:</p>
<div class="highlight-js notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">simple</span> <span class="o">=</span> <span class="p">{</span><span class="nx">id</span><span class="o">:</span><span class="s1">&#39;simple&#39;</span><span class="p">,</span> <span class="nx">nonp</span><span class="o">:</span><span class="p">{},</span> <span class="nx">X</span><span class="o">:</span><span class="p">{</span><span class="kc">true</span><span class="o">:</span><span class="mf">0.2</span><span class="p">},</span> <span class="nx">Y</span><span class="o">:</span><span class="p">{</span><span class="kc">true</span><span class="o">:</span><span class="mf">0.8</span><span class="p">}}</span>
<span class="nx">dnf</span><span class="p">([</span><span class="nx">given</span><span class="p">,[</span><span class="nx">and</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">,[</span><span class="nx">not</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">]],[</span><span class="nx">and</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,[</span><span class="nx">not</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">]]])</span>

<span class="c1">// result is:</span>
<span class="p">[</span><span class="nx">divide</span><span class="p">,[],[]]</span>

<span class="nx">prob</span><span class="p">([</span><span class="nx">given</span><span class="p">,[</span><span class="nx">and</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">,[</span><span class="nx">not</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">]],[</span><span class="nx">and</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">,[</span><span class="nx">not</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">]]],</span><span class="nx">s</span><span class="p">)</span>

<span class="c1">// result is:</span>
<span class="mi">1</span>
</pre></div>
</div>
<p>There is one other complications that the probability calculation needs to handle.  In the <cite>simple</cite> example above, consider the probability of <cite>[or,’X’,’Y’]</cite>. The formula is DNF, but we can’t simple look up and add the probabilities of ‘X’ and ‘Y’.  The reason is that <cite>X</cite> and <cite>Y</cite> overlap if you consider all combinations. The possibilities where <cite>X</cite> is true are <cite>X and Y</cite> and <cite>X and not Y</cite>.  The possibilities where <cite>Y</cite> is true are <cite>Y and X</cite> and <cite>Y and not X</cite>.  So, they overlap on <cite>X and Y</cite> and we need to ensure that that possibility isn’t double counted. In other words, the true sum is the probabilities of <cite>X and Y</cite> + <cite>X and not Y</cite> + <cite>not X and Y</cite>, which equals <cite>0.2 * 0.8 + 0.2 * (1-0.8) + (1-0.2)*0.8 == 0.84</cite></p>
<p>The function <a class="reference internal" href="#jprobs" title="jprobs"><code class="xref js js-func docutils literal notranslate"><span class="pre">jprobs()</span></code></a> takes care of avoiding duplications in the probability calculation.  It does this pretty much as we would do it naturally: it expands variables in each term of the disjunctive list and marks every combination as “used” in a bitarray, while adding up the probabilities of terms.  The bitarray is simply a true/false value (i.e. “used” or “not used”), indexed by the logical combination of possible variables.  So, ‘not X and not Y’ would be index 0, ‘not X and Y’ would be index 1, ‘X and not Y` would be index 2, and <cite>X and Y</cite> would be index 3.  We always use “binary count order” of the variables, where the variables themselves are in alphabetical order. The helper function of <a class="reference internal" href="#allvars" title="allvars"><code class="xref js js-func docutils literal notranslate"><span class="pre">allvars()</span></code></a> expands a term to cover all possible combinations of variables.  Further helper functions of <a class="reference internal" href="#vars2x" title="vars2x"><code class="xref js js-func docutils literal notranslate"><span class="pre">vars2x()</span></code></a> and <a class="reference internal" href="#x2v" title="x2v"><code class="xref js js-func docutils literal notranslate"><span class="pre">x2v()</span></code></a> convert variable combinations to index values and vice versa.</p>
</div>
</div>
</div>
<div class="section" id="indices-and-tables">
<h1>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></li>
<li><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></li>
<li><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></li>
</ul>
<div class="section" id="the-main-interface-to-the-probability-calculator">
<h2>The main interface to the probability calculator<a class="headerlink" href="#the-main-interface-to-the-probability-calculator" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="calcvars">
<code class="descname">calcvars</code><span class="sig-paren">(</span><em>Content</em><span class="sig-paren">)</span><a class="headerlink" href="#calcvars" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the text in Content, and calculate all the formulas in backticks in the content. Return the text, but now with the formulas (and possible results) in &lt;code&gt;…&lt;/code&gt; tags.</p>
<p>Broadly, calcvars first uses <a class="reference internal" href="#tickconvert" title="tickconvert"><code class="xref js js-func docutils literal notranslate"><span class="pre">tickconvert()</span></code></a> to convert the formulas in backticks to tagged formulas, as well as extract a formula list.  Then, it sorts the formulas in order of dependencies (of variables).  The third step is to actually interpret the formulas and store the results in an object called Rlist.  Lastly, we process the Rlist and plug any results from the formulas into the appropriate place in the html text (the right place was previously placemarked by tickconvert.  Basically, it created a tag called &lt;fi&gt; for every formula, numbered i, where the result should go). After placing the results, we return the resulting html string.</p>
<p>Calcvars is a “top level” function that you can play with from the node commandline.  So, start node and <cite>.load pcalc.js</cite>. Then, try <cite>calcvars(“&lt;p&gt;`probability of Y given X is 50%`&lt;/p&gt;&lt;p&gt;`probability of X is 50%`&lt;/p&gt;&lt;p&gt;So, the `%probability of Y?`&lt;/p&gt;”)</cite>. The result will be a string with html text, where the backticks have been replaced by html <cite>&lt;code&gt;</cite> tags, including <cite>&lt;span&gt;</cite> tags for formulas and results.  The formula and result classes have a suffix of ‘A’, ‘B’ or ‘C’. These indicate respectively whether the formula is an “assignment” (i.e. has an “=” or the keyword “is”), or a formula that needs hiding as soon as a result is available, or a formula that needs display together with the result.  Having different class names for each of these cases makes it easy to control the display with stylesheets.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>Content</strong> (<em>string</em>) – text as html string, which may contain calculator formulas inside backticks</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>string</strong> – same content is returned, but now formulas are marked up inside &lt;code&gt;…&lt;/code&gt; tags, including possible results</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="calcs">
<code class="descname">calcs</code><span class="sig-paren">(</span><em>fs</em>, <em>Net</em><span class="sig-paren">)</span><a class="headerlink" href="#calcs" title="Permalink to this definition">¶</a></dt>
<dd><p>Process a (sorted) list of formulas of the structure <cite>[[h,fid,formula]…]</cite>, where <cite>h</cite> is the sort key (variable dependency “height”), <cite>fid</cite> is the formula identifier of the form <cite>f01</cite>, and <cite>formula</cite> is a string with the formula text in the pcalc syntax.</p>
<p>The sorted list will have two major groups of probability formulas: assignments and calculations.  Assignments are processed first and used to build the equivalent of a Bayes network.  This network is then “completed” using <a class="reference internal" href="#completor" title="completor"><code class="xref js js-func docutils literal notranslate"><span class="pre">completor()</span></code></a>. Among other things, the completor function checks if any conditional variable has an incomplete set of conditions, in which case it uses a “noisy-or” procedure to complete the conditions.  The completor function also makes a list of variables that each conditional variable depends on, and binary-count ordered probabilities for all combinations of those variables.  All this is stored in the Net object, whose reference was passed into the calcs function.   When the Net object is complete, the calcs function will calculate the results of the remaining calculation functions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>fs</strong> (<em>array</em>) – sorted list of formulas</li>
<li><strong>Net</strong> (<em>object</em>) – a probability network object, for example <cite>{“id”:”mynet”, nonp:{}, “X”:{true:0.5}, “Y”:[[0.6, “X”],[0.2, [not,”X”]]] }</cite></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>object</strong> – the calcs result is an object with formula ids as keys and the formula result as value – only for formulas that actually have results. result structure: <cite>{‘f0’:res0, ‘f1’:res1,…}</cite></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="tickconvert">
<code class="descname">tickconvert</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#tickconvert" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a text (html) string with formulas in backticks, to a text (html) string where formulas are in code,span formulas, and span result tags</p>
<p>Note 1: the function processes a text string character-by-character from the last character to the first.  It does this, because it is easier to identify create the starting html tags (e.g. code etc.) if you already have the formula contents.  However, this means that creating “types” for the result tags is a separate step, because trying to do it in the same (major) loop can result in an error where the type from a prior formula gets attached to the the result tag.</p>
<p>The code structure for the formulas is as follows:</p>
<blockquote>
<div><ul class="simple">
<li>the <cite>&lt;code&gt;</cite> tag has a class of “pcalc”</li>
<li>the formula is wrapped in a <cite>&lt;span&gt;</cite> tag with a class of “formulaA”, “formulaB” or “formulaC”. The “A” suffix is used for assignment formulas, for example <cite>pr X = 50%</cite>.  The “B” suffix is used for calculation formulas that do not have a question mark at the end, for example <cite>pr X</cite>.  The “C” suffix is used for calculation formulas that _do_ have a question mark at the end, for example <cite>pr X?</cite>.  These suffixes enable the users to indicate whether they want a calculation to show the formula together with the result (option C), or to hide the formula and only show the result (option B).  Assignment formulas (option A) are always shown.  Having these options encoded as class types enables us to control the display via CSS.</li>
<li>the result is wrapped in a <cite>&lt;span&gt;</cite> tag with a class of “resultA”, “resultB” or “resultC”, with the same meaning as the formula tags</li>
</ul>
</div></blockquote>
<p>Note 2: we do a minimal check for having an even number of backticks.  An uneven one means that there is a backtick missing.</p>
<p>Note 3: backticks can be escaped in the source text in the usual way – prefix the backtick with a backslash</p>
<p>Note 4: part of the reason for using regex to do the transformation is so that we do not rely on DOM processing.  This avoids possible cross site scripting malware, and also makes the pcalc module more independent from any IO interfacing.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<em>string</em>) – the (html) text string that contains formulas in backticks</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>string</strong> – the html string where formulas are now inside <cite>&lt;code&gt;</cite> and <cite>&lt;span&gt;</cite> tags</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="sortfs">
<code class="descname">sortfs</code><span class="sig-paren">(</span><em>Fs</em><span class="sig-paren">)</span><a class="headerlink" href="#sortfs" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort formulas in order of maximum “height” of variables. Given an object  <cite>Fs={ ‘f1’:{‘F’:’prob X=0.5’}, ‘f2’:{‘F’: ‘prob Y=0.5’}…}</cite> return <cite>[[height,fid,F]…</cite></p>
<p>The “height” is the recursively calculated length of dependent variables that appear in the conditions that a variable depends on.  A simple definition like <cite>pr X=0.5</cite> means that the variable X does not depend on any  other variable, and so has a length of zero.  In <cite>pr Y given X=0.5</cite>, the variable Y depends on X, and so has a length of 1.  In <cite>pr Z given X or Y = 0.7</cite>, the variable Z depends on X and Y, of which Y has the longer dependency length, and so Z has a length of one more than Y (i.e. length of Z = 2).  Formulas that are not assignments, but simple calculations are given an arbitrarily long  length (1000) so that they come last in the sort order.  That is because calculations need to be performed after all assignments have been evaluated.</p>
<p>Along the way, the sort function also creates a global object called <a class="reference internal" href="#Dlist" title="Dlist"><code class="xref js js-func docutils literal notranslate"><span class="pre">Dlist()</span></code></a>, which contains a dependency list for each variable.  For example, {‘X’:null, ‘Y’:[‘X’], ‘Z’:[‘X’,’Y’]}.   The object is global and exported, in order to support external modules such as the diagram generator.  Internally, the sort routine uses Sets to update the Dlist (to avoid appending duplicate variables), but later converts the Dlist back to a simple object.</p>
<p>The relationship between Dlist and sorting the formulas is that a formula height is the height of its highest variable (as with the X,Y,Z example above).  So, first we need to calculate the height of each variable in a formula, and then determine the highest of those variables.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>Fs</strong> (<em>object</em>) – object that contains formulas</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>array</strong> – result is a sorted array of formulas <cite>[[h,fid,formula]…]</cite>, with an integer (h) “variable dependency height” as the sorting key</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="height">
<code class="descname">height</code><span class="sig-paren">(</span><em>node</em>, <em>D</em>, <em>curpath</em><span class="sig-paren">)</span><a class="headerlink" href="#height" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a node name (key) and a simple dependency structure (D), recursively calculate the dependency length for the node. Keep track which nodes have already been visited (curpath), because we don’t want to get stuck in infinite loops.  As a result, the dependency structure is treated as an acyclic graph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>node</strong> (<em>string</em>) – the node in the graph for which we want to calculate the “height”</li>
<li><strong>D</strong> (<em>object</em>) – a simple dependency structure, e.g. {‘X’:null, ‘Y’:[‘X’], ‘Z’:[‘X’,’Y’]}</li>
<li><strong>curpath</strong> (<em>array</em>) – a list of already visited nodes</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>integer</strong> – integer that represents the dependency “height”, where 0 is “no dependencies”</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="Dlist">
<code class="descname">Dlist</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Dlist" title="Permalink to this definition">¶</a></dt>
<dd><p>The externally exposed object Dlist provides a simple dependency structure for variables in a probability network. For example, if Dlist contains the following: {‘X’:null,’Y’:[‘X’],’Z’:[‘X’,’Y’]}, then this represents that variable X has no dependencies, that Y depends on X and that Z depends on both X and Y.</p>
</dd></dl>

<dl class="function">
<dt id="resetcode">
<code class="descname">resetcode</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#resetcode" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove html formatting of formulas and results, and put formulas back inside backticks</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<em>string</em>) – a text string with formulas inside &lt;code&gt; tags</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>string</strong> – a string where the code and span tags are removed (including any results) and formulas are inside backticks</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="highlight">
<code class="descname">highlight</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#highlight" title="Permalink to this definition">¶</a></dt>
<dd><p>A helper function for highlight results, if the editor/webpage itself doesn’t already take care of such highlighting</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<em>string</em>) – html string with formulas already inside &lt;code&gt; tags</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>string</strong> – - same html string, but with “highlight” styling added to the resultB classes (results where the formula does not display)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="the-calculator-formula-interpreter">
<h2>The calculator formula interpreter<a class="headerlink" href="#the-calculator-formula-interpreter" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pcalc">
<code class="descname">pcalc</code><span class="sig-paren">(</span><em>S</em>, <em>U</em><span class="sig-paren">)</span><a class="headerlink" href="#pcalc" title="Permalink to this definition">¶</a></dt>
<dd><p>The top level interface to the formula interpreter. Interpret the formula in the context of the referenced probability network. Probability assignment formulas will update the network.  For example, a formula like ‘pr X is 50%` will create (or update) the network U with <cite>U[“X”] = {true: 0.5}</cite>.  Since <cite>U</cite> is an object passed by reference, the original network is updated.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first last simple">
<li><strong>S</strong> (<em>string</em>) – a text string with single formula to interpret</li>
<li><strong>U</strong> (<em>object</em>) – the structure (object passed by reference) to hold the probability network</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="tokenise">
<code class="descname">tokenise</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#tokenise" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove whitespace, separate tokens, numbers and symbols. Aside from symbols like asterisk, plus sign, etc., the tokeniser separates out “tokens” which start with a letter and are followed by letters, digits or an underscore.  These tokens are later interpreted as function names or variables.</p>
<p>Example: <cite>tokenise(‘pr Y given X is 50%’)</cite> on the node commandline will result in <cite>[ ‘pr’, ‘Y’, ‘given’, ‘X’, ‘is’, 50, ‘%’ ]</cite></p>
<p>Note 1: We pre-calculate numbers, including negative numbers. So, the minus sign in front of a number turns the number into a negative number.</p>
<p>Note 2: question mark is counted as space. This is used by the html interface (see <a class="reference internal" href="#calcs" title="calcs"><code class="xref js js-func docutils literal notranslate"><span class="pre">calcs()</span></code></a>) as a placemarker to decide whether to display the formula together with the result.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<em>string</em>) – the formula in text</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>array</strong> – a list of tokens, numbers and symbols</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pcalctok">
<code class="descname">pcalctok</code><span class="sig-paren">(</span><em>s</em>, <em>U</em><span class="sig-paren">)</span><a class="headerlink" href="#pcalctok" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret the tokens of a probability formula and possibly update the user object that contains probability variables and their values and conditions. This function is essentially the start of a recursive descent interpreter for probability math formulas.  You can see in this function that formulas are either “definitions” or “expressions”.  In other words, the grammar in this function is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pcalctok</span> <span class="o">--&gt;</span> <span class="n">definition</span> <span class="o">|</span> <span class="n">expression</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first last simple">
<li><strong>s</strong> (<em>array</em>) – array of tokens to interpret</li>
<li><strong>U</strong> (<em>object</em>) – “User space” object that contains variables, especially probability variables and their values and conditions.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="definition">
<code class="descname">definition</code><span class="sig-paren">(</span><em>s</em>, <em>U</em><span class="sig-paren">)</span><a class="headerlink" href="#definition" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret a “definition” (i.e. assignment) formula and update the user space if needed with any new variables</p>
<p>A definition can be either a simple probability definition, a conditional probability definition, or a non-probability variable assignment. So, the grammar for a definition is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">definition</span> <span class="o">--&gt;</span> <span class="n">probf</span><span class="p">,</span> <span class="p">(</span><span class="n">pdef_simple</span> <span class="o">|</span> <span class="n">pdef_given</span><span class="p">)</span>
             <span class="o">|</span> <span class="n">vardef</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first last simple">
<li><strong>s</strong> (<em>array</em>) – list (array) of tokens to interpret</li>
<li><strong>U</strong> (<em>object</em>) – “User space” object that contains variables, especially probability variables and their values and conditions.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="vardef">
<code class="descname">vardef</code><span class="sig-paren">(</span><em>s</em>, <em>U</em><span class="sig-paren">)</span><a class="headerlink" href="#vardef" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret a non-probability variable definition (i.e. assignment)</p>
<p>grammar:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vardef</span> <span class="o">--&gt;</span> <span class="n">vname</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;=&quot;</span> <span class="o">|</span> <span class="s2">&quot;is&quot;</span><span class="p">),</span> <span class="n">expression</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first last simple">
<li><strong>s</strong> (<em>array</em>) – list (array) of tokens to interpret</li>
<li><strong>U</strong> (<em>object</em>) – “User space” object that contains variables, especially probability variables and their values and conditions.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="probf">
<code class="descname">probf</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#probf" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret the probability functor (i.e. keyword that signals the start of a probability formula). No user space needs to be passed to this interpretation, because we don’t update the userspace upon seeing this keyword.  It simply acts as a signal in the processing of a formula.</p>
<p>grammar:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">probf</span> <span class="o">--&gt;</span> <span class="p">(</span><span class="s2">&quot;probability of&quot;</span> <span class="o">|</span> <span class="s2">&quot;chance of&quot;</span> <span class="o">|</span> <span class="s2">&quot;chance&quot;</span> <span class="o">|</span> <span class="s2">&quot;probability&quot;</span> <span class="o">|</span> <span class="s2">&quot;prob&quot;</span> <span class="o">|</span> <span class="s2">&quot;pr&quot;</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first last simple">
<li><strong>s</strong> (<em>array</em>) – list (array) of tokens to interpret</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pdef_simple">
<code class="descname">pdef_simple</code><span class="sig-paren">(</span><em>s</em>, <em>U</em><span class="sig-paren">)</span><a class="headerlink" href="#pdef_simple" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret simple probability definitions (after the <cite>prob</cite> keyword), like <cite>X=50%</cite></p>
<p>grammar:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pdef_simple</span> <span class="o">--&gt;</span> <span class="n">pvname</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;=&quot;</span> <span class="o">|</span> <span class="s2">&quot;is&quot;</span><span class="p">),</span> <span class="n">expression</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<em>array</em>) – list (array) of tokens to interpret</li>
<li><strong>U</strong> (<em>object</em>) – user space object where variable definitions are stored</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>object</strong> – interpreter result object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pdef_given">
<code class="descname">pdef_given</code><span class="sig-paren">(</span><em>s</em>, <em>U</em><span class="sig-paren">)</span><a class="headerlink" href="#pdef_given" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret conditional probability definitions (after the <cite>prob</cite> keyword), like <cite>X given Y=50%</cite></p>
<p>grammar:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pdef_simple</span> <span class="o">--&gt;</span> <span class="n">pargiven</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;=&quot;</span> <span class="o">|</span> <span class="s2">&quot;is&quot;</span><span class="p">),</span> <span class="n">expression</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<em>array</em>) – list (array) of tokens to interpret</li>
<li><strong>U</strong> (<em>object</em>) – user space object where variable definitions are stored</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>object</strong> – interpreter result object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pargiven">
<code class="descname">pargiven</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#pargiven" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret conditional probability variable that comes before the condition (i.e. before “given”). Pargiven takes care of the parentheses that may wrap the conditional part, for example in <cite>pr(X given Y)=0.5</cite></p>
<p>grammar:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pargiven</span> <span class="o">--&gt;</span> <span class="s2">&quot;(&quot;</span> <span class="n">pargiven</span> <span class="s2">&quot;)&quot;</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<em>array</em>) – list (array) of tokens to interpret</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>object</strong> – interpreter result object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pgiven">
<code class="descname">pgiven</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#pgiven" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret conditional probability variable that comes before the condition (i.e. before “given”).</p>
<p>grammar:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pgiven</span> <span class="o">--&gt;</span> <span class="n">vname</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;:&quot;</span> <span class="o">|</span> <span class="s2">&quot;given&quot;</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<em>array</em>) – list (array) of tokens to interpret</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>object</strong> – interpreter result object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pvname">
<code class="descname">pvname</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#pvname" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret a probability variable that may be wrapped in parentheses, as in <cite>pr(X)=0.5</cite></p>
<p>grammar:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pvname</span> <span class="o">--&gt;</span> <span class="s2">&quot;(&quot;</span> <span class="n">pvname</span> <span class="s2">&quot;)&quot;</span> <span class="o">|</span> <span class="n">vname</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<em>array</em>) – list (array) of tokens to interpret</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>object</strong> – interpreter result object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="vname">
<code class="descname">vname</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#vname" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret a variable name</p>
<p>grammar:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vname</span> <span class="o">--&gt;</span> <span class="n">pvname</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<em>array</em>) – list (array) of tokens to interpret</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>object</strong> – interpreter result object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="expression">
<code class="descname">expression</code><span class="sig-paren">(</span><em>s</em>, <em>V</em>, <em>U</em><span class="sig-paren">)</span><a class="headerlink" href="#expression" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret an arithmetic expression, including functions of numbers, of which probability functions are are one type.</p>
<p>grammar:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">expression</span> <span class="o">-&gt;</span> <span class="n">term</span> <span class="n">asop</span> <span class="o">|</span> <span class="n">asop</span>
<span class="n">term</span> <span class="o">-&gt;</span> <span class="n">factor</span> <span class="n">emdop</span>
<span class="n">factor</span> <span class="o">-&gt;</span> <span class="s2">&quot;(&quot;</span> <span class="n">expression</span> <span class="s2">&quot;)&quot;</span> <span class="o">|</span> <span class="n">FUNC</span>
<span class="n">asop</span> <span class="o">-&gt;</span> <span class="s2">&quot;+&quot;</span> <span class="n">term</span> <span class="n">asop</span> <span class="o">|</span> <span class="s2">&quot;-&quot;</span> <span class="n">term</span> <span class="n">asop</span> <span class="o">|</span> <span class="n">EMPTY</span>
<span class="n">emdop</span> <span class="o">-&gt;</span> <span class="s2">&quot;^&quot;</span> <span class="n">factor</span> <span class="n">emdop</span> <span class="o">|</span> <span class="s2">&quot;*&quot;</span> <span class="n">factor</span> <span class="n">emdop</span> <span class="o">|</span> <span class="s2">&quot;/&quot;</span> <span class="n">factor</span> <span class="n">emdop</span> <span class="o">|</span> <span class="n">EMPTY</span>
</pre></div>
</div>
<p>Note-1: some parts of an expression may be empty, like the “add or subtract” operator part.  That means the return value parameter “err” has a special value (-1) which signals a non-error empty return.  In practice, this means that the return of “errors” for the purpose of notifying users of “expectations” in the expression is not very applicable, because it is hard to decide between an expected symbol and a legitimate empty return.</p>
<p>Note-2: the FUNC factor encapsulates functions of numbers, of which the sub-grammar of probability functions is one type. So, you could comment out the probability function part in <a class="reference internal" href="#func" title="func"><code class="xref js js-func docutils literal notranslate"><span class="pre">func()</span></code></a> and have just an arithmetic interpreter.</p>
<p>Note-3: the structure of each of these interpreter functions is to test whether the next elements of the token stream (i.e. parameter “s”) matches some expected token(s) and if so, return with a value.  If it doesn’t match, then code drops to the next section of the function to try something else.  So, each test consists only of an if…return.  There is usually no explicit “…else “, just a “continue to the next lines of code if the test was unsuccessful”.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<em>array</em>) – list (array) of tokens to interpret</li>
<li><strong>V</strong> (<em>*</em>) – current value in the recursive interpretation of an expression.  May be array or number</li>
<li><strong>U</strong> (<em>object</em>) – user space object where variable definitions are stored</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>object</strong> – interpreter result object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="term">
<code class="descname">term</code><span class="sig-paren">(</span><em>s</em>, <em>V</em>, <em>U</em><span class="sig-paren">)</span><a class="headerlink" href="#term" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret an arithmetic term</p>
<p>grammar (see also the full grammar of arithmetic expressions):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">term</span> <span class="o">-&gt;</span> <span class="n">factor</span> <span class="n">emdop</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<em>array</em>) – list (array) of tokens to interpret</li>
<li><strong>V</strong> (<em>*</em>) – current value in the recursive interpretation of an expression.  May be array or number</li>
<li><strong>U</strong> (<em>object</em>) – user space object where variable definitions are stored</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>object</strong> – interpreter result object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="factor">
<code class="descname">factor</code><span class="sig-paren">(</span><em>s</em>, <em>V</em>, <em>U</em><span class="sig-paren">)</span><a class="headerlink" href="#factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret an arithmetic factor</p>
<p>grammar (see also the full grammar of arithmetic expressions):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">factor</span> <span class="o">-&gt;</span> <span class="s2">&quot;(&quot;</span> <span class="n">expression</span> <span class="s2">&quot;)&quot;</span> <span class="o">|</span> <span class="n">FUNC</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<em>array</em>) – list (array) of tokens to interpret</li>
<li><strong>V</strong> (<em>*</em>) – current value in the recursive interpretation of an expression.  May be array or number</li>
<li><strong>U</strong> (<em>object</em>) – user space object where variable definitions are stored</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>object</strong> – interpreter result object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="asop">
<code class="descname">asop</code><span class="sig-paren">(</span><em>s</em>, <em>V</em>, <em>U</em><span class="sig-paren">)</span><a class="headerlink" href="#asop" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret an arithmetic “add or subtract” subterm</p>
<p>grammar (see also the full grammar of arithmetic expressions):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">asop</span> <span class="o">-&gt;</span> <span class="s2">&quot;+&quot;</span> <span class="n">term</span> <span class="n">asop</span> <span class="o">|</span> <span class="s2">&quot;-&quot;</span> <span class="n">term</span> <span class="n">asop</span> <span class="o">|</span> <span class="n">EMPTY</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<em>array</em>) – list (array) of tokens to interpret</li>
<li><strong>V</strong> (<em>*</em>) – current value in the recursive interpretation of an expression.  May be array or number</li>
<li><strong>U</strong> (<em>object</em>) – user space object where variable definitions are stored</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>object</strong> – interpreter result object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="emdop">
<code class="descname">emdop</code><span class="sig-paren">(</span><em>s</em>, <em>value</em>, <em>U</em><span class="sig-paren">)</span><a class="headerlink" href="#emdop" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret an “exponentiation, multiply or divide” subterm</p>
<p>grammar (see also the full grammar of arithmetic expressions):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">emdop</span> <span class="o">-&gt;</span> <span class="s2">&quot;^&quot;</span> <span class="n">factor</span> <span class="n">emdop</span> <span class="o">|</span> <span class="s2">&quot;*&quot;</span> <span class="n">factor</span> <span class="n">emdop</span> <span class="o">|</span> <span class="s2">&quot;/&quot;</span> <span class="n">factor</span> <span class="n">emdop</span> <span class="o">|</span> <span class="n">EMPTY</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<em>array</em>) – list (array) of tokens to interpret</li>
<li><strong>value</strong> (<em>*</em>) – current value in the recursive interpretation of an expression.  May be array or number</li>
<li><strong>U</strong> (<em>object</em>) – user space object where variable definitions are stored</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>object</strong> – interpreter result object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="token">
<code class="descname">token</code><span class="sig-paren">(</span><em>s</em>, <em>toks</em><span class="sig-paren">)</span><a class="headerlink" href="#token" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret a token (non-variable symbol) in an arithmetic expression.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<em>array</em>) – list (array) of tokens to interpret</li>
<li><strong>toks</strong> (<em>array</em>) – the list of strings that token has to be in, in order to be considered a valid token</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>object</strong> – interpreter result object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="func">
<code class="descname">func</code><span class="sig-paren">(</span><em>s</em>, <em>U</em><span class="sig-paren">)</span><a class="headerlink" href="#func" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret a function term</p>
<p>grammar (see also the full grammar of arithmetic expressions):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">func</span> <span class="o">--&gt;</span> <span class="s2">&quot;round&quot;</span> <span class="o">|</span> <span class="s2">&quot;rounded&quot;</span>
        <span class="o">|</span> <span class="s2">&quot;percent&quot;</span> <span class="o">|</span> <span class="s2">&quot;%&quot;</span>
        <span class="o">|</span> <span class="n">number</span>
        <span class="o">|</span> <span class="n">probf</span><span class="p">,</span> <span class="n">pexpression</span>
        <span class="o">|</span> <span class="n">vname</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<em>array</em>) – list (array) of tokens to interpret</li>
<li><strong>U</strong> (<em>object</em>) – user space object where variable definitions are stored</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>object</strong> – interpreter result object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="number">
<code class="descname">number</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#number" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret a number</p>
<p>grammar (see also the full grammar of arithmetic expressions):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">number</span> <span class="o">--&gt;</span> <span class="n">NUMBER</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;%&quot;</span><span class="p">]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<em>array</em>) – list (array) of tokens to interpret</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>object</strong> – interpreter result object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pexpression">
<code class="descname">pexpression</code><span class="sig-paren">(</span><em>s</em>, <em>U</em><span class="sig-paren">)</span><a class="headerlink" href="#pexpression" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret probability expressions, which appear after signalling a probability statement in the main arithmetic grammar as a function (see above), or may appear recursively in conditional probability expressions (e.g. after the “given” keyword).</p>
<p>grammar (see also the full grammar of arithmetic expressions):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>pexpression -&gt; pexp | vpargiven      // evaluation only happens here
pexp -&gt; pterm poperation
pterm -&gt; &quot;-&quot; pterm | plogic
plogic -&gt; &quot;(&quot; pterm &quot;)&quot; | vname
poperation -&gt; &quot;&amp;&quot; pexp | &quot;|&quot; pexp | EMPTY
vpargiven -&gt; &quot;(&quot; vpargiven &quot;)&quot; | vgiven
vgiven -&gt; pexp (&quot;:&quot; | &quot;given&quot;) pexp

Note: evaluation of a probability expression only happens at the &quot;top level&quot; (in pexp or vpargiven).  At this point we call :func:`prob` to evaluate the expression in the context of the user space object that defines the probability variables (and network of dependencies -- i.e. the Bayesnet).  The remainder of the grammar is actually only parsing the probability expresssion.
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<em>array</em>) – list (array) of tokens to interpret</li>
<li><strong>U</strong> (<em>object</em>) – user space object where variable definitions are stored</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>object</strong> – interpreter result object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="vpargiven">
<code class="descname">vpargiven</code><span class="sig-paren">(</span><em>s</em>, <em>value</em>, <em>U</em><span class="sig-paren">)</span><a class="headerlink" href="#vpargiven" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret conditional variables in probability expressions, which is really <a class="reference internal" href="#vgiven" title="vgiven"><code class="xref js js-func docutils literal notranslate"><span class="pre">vgiven()</span></code></a> but possibly wrapped in parentheses.</p>
<p>grammar (see also the full grammar of probability expressions):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vpargiven</span> <span class="o">-&gt;</span> <span class="s2">&quot;(&quot;</span> <span class="n">vpargiven</span> <span class="s2">&quot;)&quot;</span> <span class="o">|</span> <span class="n">vgiven</span>
</pre></div>
</div>
<p>Note that this mirrors <a class="reference internal" href="#pargiven" title="pargiven"><code class="xref js js-func docutils literal notranslate"><span class="pre">pargiven()</span></code></a> in conditional probability assignments, but is kept separate to avoid unintended cross-overs in the interpretation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<em>array</em>) – list (array) of tokens to interpret</li>
<li><strong>value</strong> (<em>*</em>) – current value in the recursive interpretation of an expression.  May be array or number</li>
<li><strong>U</strong> (<em>object</em>) – user space object where variable definitions are stored</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>object</strong> – interpreter result object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="vgiven">
<code class="descname">vgiven</code><span class="sig-paren">(</span><em>s</em>, <em>value</em>, <em>U</em><span class="sig-paren">)</span><a class="headerlink" href="#vgiven" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret conditional variables in probability expressions.</p>
<p>grammar (see also the full grammar of probability expressions):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>vgiven -&gt; &quot;(&quot; vpargiven &quot;)&quot; | vgiven

Note that this mirrors :func:`pgiven` in conditional probability assignments, but is kept separate to avoid unintended cross-overs in the interpretation.
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<em>array</em>) – list (array) of tokens to interpret</li>
<li><strong>value</strong> (<em>*</em>) – current value in the recursive interpretation of an expression.  May be array or number</li>
<li><strong>U</strong> (<em>object</em>) – user space object where variable definitions are stored</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>object</strong> – interpreter result object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pexp">
<code class="descname">pexp</code><span class="sig-paren">(</span><em>s</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#pexp" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret a non-assignment probability expressions</p>
<p>grammar (see also the full grammar of probability expressions):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pexp</span> <span class="o">-&gt;</span> <span class="n">pterm</span> <span class="n">poperation</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<em>array</em>) – list (array) of tokens to interpret</li>
<li><strong>value</strong> (<em>*</em>) – current value in the recursive interpretation of an expression.  May be array or number</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>object</strong> – interpreter result object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pterm">
<code class="descname">pterm</code><span class="sig-paren">(</span><em>s</em>, <em>value</em>, <em>U</em><span class="sig-paren">)</span><a class="headerlink" href="#pterm" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret probability term</p>
<p>grammar (see also the full grammar of probability expressions):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pterm</span> <span class="o">-&gt;</span> <span class="s2">&quot;-&quot;</span> <span class="n">pterm</span> <span class="o">|</span> <span class="n">plogic</span>
</pre></div>
</div>
<p>Note that this mirrors <a class="reference internal" href="#pargiven" title="pargiven"><code class="xref js js-func docutils literal notranslate"><span class="pre">pargiven()</span></code></a> in conditional probability assignments, but is kept separate to avoid unintended cross-overs in the interpretation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<em>array</em>) – list (array) of tokens to interpret</li>
<li><strong>value</strong> (<em>*</em>) – current value in the recursive interpretation of an expression.  May be array or number</li>
<li><strong>U</strong> (<em>object</em>) – user space object where variable definitions are stored</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>object</strong> – interpreter result object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="plogic">
<code class="descname">plogic</code><span class="sig-paren">(</span><em>s</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#plogic" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret a logic expression in a probability expression</p>
<p>grammar (see also the full grammar of probability expressions):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">plogic</span> <span class="o">-&gt;</span> <span class="s2">&quot;(&quot;</span> <span class="n">pterm</span> <span class="s2">&quot;)&quot;</span> <span class="o">|</span> <span class="n">vname</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<em>array</em>) – list (array) of tokens to interpret</li>
<li><strong>value</strong> (<em>*</em>) – current value in the recursive interpretation of an expression.  May be array or number</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>object</strong> – interpreter result object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="poperation">
<code class="descname">poperation</code><span class="sig-paren">(</span><em>s</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#poperation" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret a logical operation as a sub expression of probability logic</p>
<p>grammar (see also the full grammar of probability expressions):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">poperation</span> <span class="o">-&gt;</span> <span class="s2">&quot;&amp;&quot;</span> <span class="n">pexp</span> <span class="o">|</span> <span class="s2">&quot;|&quot;</span> <span class="n">pexp</span> <span class="o">|</span> <span class="n">EMPTY</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>s</strong> (<em>array</em>) – list (array) of tokens to interpret</li>
<li><strong>value</strong> (<em>*</em>) – current value in the recursive interpretation of an expression.  May be array or number</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>object</strong> – interpreter result object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="the-core-probability-calculator">
<h2>The core probability calculator<a class="headerlink" href="#the-core-probability-calculator" title="Permalink to this headline">¶</a></h2>
<p>The DNF section of the calculator transforms formulas into <strong>Disjunctive Normal Form</strong>, where negations are pushed inwards until they are next to simple variables, and where “and” is distributed over “or”.  The resulting formula is a simple list of conjunctions. The DNF section of the calculator consists of the following functions:</p>
<dl class="function">
<dt id="completor">
<code class="descname">completor</code><span class="sig-paren">(</span><em>Net</em><span class="sig-paren">)</span><a class="headerlink" href="#completor" title="Permalink to this definition">¶</a></dt>
<dd><p>Complete the conditional probabilities for any incomplete variable, using the “noisy-or” negation of the product of negations.</p>
<p>Outline: First we make a list of every variable in the network for reference, and store that in the object as <cite>vars</cite>. for every variable in the network, check if it is “complete” – that is, if all logical combinations of its dependencies have been listed, together with their conditional probabilities. For example, if variable Y has a dependency, <cite>[0.5,’X’]</cite>, then for completeness it should also have a dependency for its logical opposite, like <cite>[0.2,[not,’X’]]</cite>. If the conditions are incomplete, then we collect all the defined conditions and make a list of all the combinations of those conditions, calling each combination a “Factor”.  The probability of a factor is the negation (i.e. one minus) of the product of negations of each positive condition in the factor.  This is the so called “noisy or” approach.  For example, if variable <cite>Z</cite> has the conditions <cite>[ [0.2,’X’], [0.8,’Y’]]</cite>, then to complete the conditions we first calculate all the factors:</p>
<div class="highlight-js notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">0</span><span class="p">,[</span><span class="nx">not</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">],[</span><span class="nx">not</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">]],</span>    <span class="c1">// no positive conditions in this factor, so prob = 0</span>
<span class="p">[</span><span class="mf">0.2</span><span class="p">,[</span><span class="nx">not</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">],</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span>         <span class="c1">// one positive condition in this factor, so prob = 1-0.8 = 0.2</span>
<span class="p">[</span><span class="mf">0.8</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">,[</span><span class="nx">not</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">]]</span>         <span class="c1">// one positive condition in this factor, so prob = 1-0.2 = 0.8</span>
<span class="p">[</span><span class="mf">0.84</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span>              <span class="c1">// two positive conditions, so prob = 1-(1-0.2)*(1-0.8) = 0.84</span>
</pre></div>
</div>
<p>The combinations of factors are identified by the two inner for loops (using <cite>i</cite> and <cite>j</cite>) as the indices.  We cycle through the factors (using <cite>i</cite>) and for each factor cycle through the factors again (using <cite>j</cite>), in order to build the combination <cite>[and,Factor(i),Factor(j)]</cite>.  Note that the factors are arbitrary formulas, so we use <a class="reference internal" href="#dnf" title="dnf"><code class="xref js js-func docutils literal notranslate"><span class="pre">dnf()</span></code></a> to standardise the formula.  This may mean that the formulas reduce to <cite>[]</cite>, so we only push the factor if it has content.  The resulting list (<cite>Combos</cite>) is the replacement for the conditional formulas, which are now completed.</p>
<p>Whether or not the completed variables were calculated through the noisy-or process, or whether they were predefined, we ensure that all conditional variables are DNF by applying <a class="reference internal" href="#condnf" title="condnf"><code class="xref js js-func docutils literal notranslate"><span class="pre">condnf()</span></code></a>. Lastly, we make a simple list of the probabilities in binary count order of the variables in the conditions (we look up the combination in the list of factors, and use the listed probability if the combination matches the factor).  Essentially what this means is that we don’t really need the conditions themselves anymore – we simply simply look up the probability by using the binary count index of the relevant combination of variables. For example, if we’re interested in the conditional probability of <cite>[and,’X’,[not,’Y’]]</cite>, then we get <cite>Z.probs[2]</cite>  because <cite>X,not Y</cite> == <cite>10</cite> in binary, which equals <cite>2</cite> as the index.  We keep the conditional formulas (i.e. factors) in the probability network object for reference.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>Net</strong> (<em>object</em>) – the probability variable network. The orginal object (passed by reference) is updated.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>boolean</strong> – - success or failure of completion</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="condnf">
<code class="descname">condnf</code><span class="sig-paren">(</span><em>V</em>, <em>Net</em><span class="sig-paren">)</span><a class="headerlink" href="#condnf" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform conditions of conditional variables to DNF</p>
<p>We ensure that the conditions of a conditional variable in a probability network are of the simple form of a (disjunctive) list of all combinations of dependent variables. For example, consider the following example:</p>
<div class="highlight-js notranslate"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">simple</span> <span class="o">=</span><span class="p">{</span><span class="nx">id</span><span class="o">:</span><span class="s2">&quot;simple&quot;</span><span class="p">,</span><span class="nx">nonp</span><span class="o">:</span><span class="p">{},</span>
               <span class="nx">X</span><span class="o">:</span><span class="p">{</span><span class="kc">true</span><span class="o">:</span><span class="mf">0.2</span><span class="p">},</span>
               <span class="nx">Y</span><span class="o">:</span><span class="p">{</span><span class="kc">true</span><span class="o">:</span><span class="mf">0.8</span><span class="p">},</span>
               <span class="nx">Z</span><span class="o">:</span><span class="p">{[</span><span class="s2">&quot;#&quot;</span><span class="p">]</span><span class="o">:</span><span class="p">[</span> <span class="p">[</span><span class="mf">0.8</span><span class="p">,[</span><span class="nx">and</span><span class="p">,</span><span class="s2">&quot;X&quot;</span><span class="p">,</span><span class="s2">&quot;Y&quot;</span><span class="p">]],</span> <span class="p">[</span><span class="mf">0.3</span><span class="p">,[</span><span class="nx">or</span><span class="p">,[</span><span class="nx">and</span><span class="p">,</span><span class="s2">&quot;X&quot;</span><span class="p">,[</span><span class="nx">not</span><span class="p">,</span><span class="s2">&quot;Y&quot;</span><span class="p">]],[</span><span class="nx">and</span><span class="p">,[</span><span class="nx">not</span><span class="p">,</span><span class="s2">&quot;X&quot;</span><span class="p">],</span><span class="s2">&quot;Y&quot;</span><span class="p">]]]</span> <span class="p">]}};</span>
</pre></div>
</div>
<p>Variable <cite>Z</cite> has two conditions, each of which is already DNF.  We’re going to cycle through all combinations of the dependent variables of Z (the outer for loop, indexed by <cite>h</cite>) – so, <cite>[-X,-Y],[-X,Y],[X,-Y]</cite> and <cite>[X,Y]</cite> (in abbreviated notation).  Each combination is initialised with a probability of 0.  The next inner loop (indexed by <cite>k</cite>), cycles through each of the conditional formulas (called Combos).</p>
<p>The first of the Combos is <cite>[0.8,[and,”X”,”Y”]]</cite> of which <cite>[and,”X”,”Y”]</cite> is the condition itself. The condition does not start with “or” and has all the variables that <cite>Z</cite> depends on, so we skip most of the inner loop, going for a simple comparison against the current variable combination (<cite>h</cite>).  That is, we calculate the index of Combo and compare against <cite>h</cite>.  If there is a match, then we append Combo as the probability and formula for that variable combination.</p>
<blockquote>
<div>The next Combo <cite>[0.3,[or,[and,”X”,[not,”Y”]],[and,[not,”X”],”Y”]]]</cite> does start with an “or”, so we drop into the further inner loops that consider each term of the “or” clause. For each term, we create a possible sublist of terms expanded with missing variables. Then, for the expanded list we compare each term against the current variable combination. If there is a match, we append the subterm (and its probabilty inherited from the orignal Combo) as the probability formula for that variable combination.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>V</strong> (<em>string</em>) – variable in the probability network whose conditions we’re transforming</li>
<li><strong>Net</strong> (<em>object</em>) – the probability network</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>array</strong> – the transformed list of conditionsl formulas</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orcomplete">
<code class="descname">orcomplete</code><span class="sig-paren">(</span><em>V</em>, <em>Net</em><span class="sig-paren">)</span><a class="headerlink" href="#orcomplete" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the conditions of a conditional probability are complete, i.e. all logical combinations of variables are specified</p>
<p>From my notes of 2018-06-20: My original thought for “or complete” was that a variable that was conditionally defined wouldn’t need “noisy-or” treatment (negated sum of negated products of the positive conditional variables) if the disjunctive collection of dependencies “cancelled” each other out.  That is, the the conjunction of dependent clauses would resolve to empty. For example, if Y has two conditions, <cite>[0.9,X],[0.5,-X]</cite> then the conditions of Y are complete, because <cite>[and,X,[not,X]]</cite> resolves to <cite>[]</cite>.  However, that didn’t work, because one clause can cancel many other clauses.  For example, if Z is dependent on Y and X, then a clause like <cite>[and,[not,X],[not,Y]]</cite> can cancel all of <cite>[and,X,Y]</cite>, <cite>[and,[not,X],Y]</cite> and <cite>[and,X,[not,Y]]</cite>.
So then I thought to do pairwise comparison: that is, a clause can only cancel one other term.  If there are left-over uncancelled terms, then that signals incompleteness.  But that didn’t work either, because some terms can be under-specificed.  As the firefox example showed, some conditions can be incomplete.  For example, if the variable <cite>Radar</cite> has the following conditions <cite>[0.3, [and,North,High]]</cite>, <cite>[0.1, [and,North,-High]]</cite>, <cite>[0.05, -North]</cite>.  The last condition is an “incomplete” specification of <cite>[0.05, -North, -High]</cite> and <cite>[0.05, -North, High]</cite>.  When the condition is expanded into the two conditions, the conditional set is complete.
This led me to the current version of <cite>orcomplete()</cite>, where I check if any of the conditions overlap – when expanded with all combinations of possibly missing variables from that condition.  If that is the case, then the conditional set is too general (i.e. underspecified) and needs noisy-or treatment to complete it.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>V</strong> (<em>string</em>) – variable for which we’re checking “or completeness” of the conditions</li>
<li><strong>Net</strong> (<em>object</em>) – probability network</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>boolean</strong> – returns <cite>true</cite> if the conditions of variable V in Net are complete</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="dnf">
<code class="descname">dnf</code><span class="sig-paren">(</span><em>Formula</em>, <em>max=10</em><span class="sig-paren">)</span><a class="headerlink" href="#dnf" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert logical formula to Disjunctive Normal Form, including resolution of contradictions and removal of duplications.</p>
<p>This function is an iterative wrapper around :func:distand, because <cite>distand</cite> won’t distribute an “and” generated by :func:distnot. This <a class="reference internal" href="#dnf" title="dnf"><code class="xref js js-func docutils literal notranslate"><span class="pre">dnf()</span></code></a> function will iterate until now further changes occur in the formula.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>Formula</strong> (<em>array</em>) – logical formula as list (array) in prefix form, with operators “and”,”or”,”not”,and relation “divide”</li>
<li><strong>max</strong> (<em>integer</em>) – maximum number of iterations to obtain disjunctive normal form</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>array</strong> – returns a formula that is the transformation of <cite>Formula</cite> into Disjunctive Normal Form</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="distand">
<code class="descname">distand</code><span class="sig-paren">(</span><em>L</em>, <em>curop=&quot;null&quot;</em><span class="sig-paren">)</span><a class="headerlink" href="#distand" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursively look for places to distribute “and” over “or” in or a simple variable, e.g. “X”. Expects list of formulas, but will handle single formula.</p>
<p>For example:</p>
<div class="highlight-js notranslate"><div class="highlight"><pre><span></span><span class="nx">distand</span><span class="p">([</span><span class="nx">or</span><span class="p">,[</span><span class="nx">not</span><span class="p">,[</span><span class="nx">and</span><span class="p">,</span><span class="s1">&#39;X&#39;</span><span class="p">,[</span><span class="nx">not</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">]]],</span><span class="s1">&#39;X&#39;</span><span class="p">,[</span><span class="nx">or</span><span class="p">,</span><span class="s1">&#39;A&#39;</span><span class="p">,</span><span class="s1">&#39;B&#39;</span><span class="p">]])</span>

<span class="c1">// result is:</span>

<span class="p">[</span> <span class="p">[</span> <span class="s1">&#39;or&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span> <span class="p">]</span> <span class="p">]</span>
</pre></div>
</div>
<p>The parameter <cite>L</cite> is type checked to ensure that it is a list of terms, where a term is either a simple variable or a list (array) consisting of an operator (“and”,”or”,”not”,”given”,”divide”), followed by any number of arguments (which themselves are terms).  The <cite>for</cite> loop of the code processes each term, taking different actions depending on the type of the term.  Two types get special attention: “not” and “and”.  The “not” term is passed into the <a class="reference internal" href="#distnot" title="distnot"><code class="xref js js-func docutils literal notranslate"><span class="pre">distnot()</span></code></a> function, which pushes negations inwards until they next to a simple variable.  For example, <cite>[not,[and,”X”,”Y”]]</cite> is transformed to <cite>[or,[not,”X”],[not,”Y”]]</cite>.</p>
<p>Processing the “and” term is the main game.  For the “and” term, we first separate all “or” subterms from non-“or” subterms.  This is achieved with the <a class="reference internal" href="#orsfirst" title="orsfirst"><code class="xref js js-func docutils literal notranslate"><span class="pre">orsfirst()</span></code></a> function. Next, if there were less than two or-subterms, we reconstruct the “and” term. If there were 2 or more or-subterms, we generate all combinations of the or-subterm arguments with <a class="reference internal" href="#combos" title="combos"><code class="xref js js-func docutils literal notranslate"><span class="pre">combos()</span></code></a>.  Each of these combinations (with the non-or subterms appended) are the new “and” terms. For example,</p>
<div class="highlight-js notranslate"><div class="highlight"><pre><span></span><span class="nx">distand</span><span class="p">([</span><span class="nx">and</span><span class="p">,</span> <span class="p">[</span><span class="nx">or</span><span class="p">,</span><span class="s2">&quot;A&quot;</span><span class="p">,</span><span class="s2">&quot;B&quot;</span><span class="p">],[</span><span class="nx">or</span><span class="p">,</span><span class="s2">&quot;C&quot;</span><span class="p">,</span><span class="s2">&quot;D&quot;</span><span class="p">],</span><span class="s2">&quot;X&quot;</span><span class="p">,</span><span class="s2">&quot;Y&quot;</span><span class="p">])</span>

<span class="c1">// results in:</span>

<span class="p">[</span> <span class="p">[</span> <span class="s1">&#39;or&#39;</span><span class="p">,</span>
   <span class="p">[</span> <span class="s1">&#39;and&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span> <span class="p">],</span>
   <span class="p">[</span> <span class="s1">&#39;and&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span> <span class="p">],</span>
   <span class="p">[</span> <span class="s1">&#39;and&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span> <span class="p">],</span>
   <span class="p">[</span> <span class="s1">&#39;and&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span> <span class="p">]</span> <span class="p">]</span> <span class="p">]</span>
</pre></div>
</div>
<p>Note that along the way, we also remove contradictory “and” clauses and omit duplicate subterms within “or” term.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>L</strong> (<em>array</em>) – list of formulas</li>
<li><strong>curop</strong> (<em>string</em>) – the “current operator” if <a class="reference internal" href="#distand" title="distand"><code class="xref js js-func docutils literal notranslate"><span class="pre">distand()</span></code></a> was recursively called from within processing another “or” or “and”</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>array</strong> – returns a formula that is one transformation further towards Disjunctive Normal Form (DNF)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="distnot">
<code class="descname">distnot</code><span class="sig-paren">(</span><em>F</em><span class="sig-paren">)</span><a class="headerlink" href="#distnot" title="Permalink to this definition">¶</a></dt>
<dd><p>recursively look for “not” in a formula, and distribute “not” over “and” or “or” expects a single Formula, but can handle singular nesting of the formula. Returns Formulas unchanged if not distribution is possible.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>F</strong> (<em>array</em>) – a single formula, like <cite>[not,[or,”X”,”Y”]]</cite></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>array</strong> – returns a formula in Negation Normal Form, i.e. where all “not” terms have been pushed inwards until they are next to simple variables</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orsfirst">
<code class="descname">orsfirst</code><span class="sig-paren">(</span><em>F</em><span class="sig-paren">)</span><a class="headerlink" href="#orsfirst" title="Permalink to this definition">¶</a></dt>
<dd><p>Move all non-or clauses to the end of the formula.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>F</strong> (<em>array</em>) – logical formula like <cite>[and,”X”,”Y”,[or,”A”,”B”]]</cite></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>object</strong> – returns an object where “ors” is a list of all or-terms, and “rest” is a list of the remaining terms</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="lookup">
<code class="descname">lookup</code><span class="sig-paren">(</span><em>F</em>, <em>Net</em>, <em>val=true</em><span class="sig-paren">)</span><a class="headerlink" href="#lookup" title="Permalink to this definition">¶</a></dt>
<dd><p>Lookup value of a variable, or of a conditional.  For example, <cite>lookup(‘Rain’,wg)</cite> or <cite>lookup([given,’Sprinkler’,[not,’Rain’]],wg)</cite></p>
<p>When looking up a single variable, the function simple uses the variable name as a key into the <cite>Net</cite> object.  When looking up a conditional formula, it uses the dependent variable as a key, and then linearly looks through the conditional formulas.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first last simple">
<li><strong>F</strong> (<em>array</em>) – string of “Variable” type, or</li>
<li><strong>Net</strong> (<em>object</em>) – probability network</li>
<li><strong>val</strong> (<em>*</em>) – particular value to look for: <cite>true</cite>, <cite>formulas</cite>, or <cite>logic</cite>. The latter reconstructs formulas into a single disjunctive formula. Todo: <a class="reference internal" href="#lookup" title="lookup"><code class="xref js js-func docutils literal notranslate"><span class="pre">lookup()</span></code></a> should also be able to lookup negations of variables i.e. <cite>lookup([not,’Rain’],wg)</cite></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="combos">
<code class="descname">combos</code><span class="sig-paren">(</span><em>List</em><span class="sig-paren">)</span><a class="headerlink" href="#combos" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate all maximally sized combinations of a formula with sub-junctions and switch functors.  In other words, distribute “or” over “and” or vice versa.
For example, <cite>combos([and,[or,A,B],[or,C,D],[or,E,F]])</cite> results in <cite>[or,[and,A,C,E],[and,A,C,F],[and,A,D,E],[and,A,D,F],[and,B,C,E],[and,B,C,F],[and,B,D,E],[and,B,D,F]]</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>List</strong> (<em>array</em>) – logic formula, especially one with “or” or “and” subterms.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>array</strong> – returns logic formula where disjunctive or conjunctive subterms have been recombined</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="combos0">
<code class="descname">combos0</code><span class="sig-paren">(</span><em>List</em><span class="sig-paren">)</span><a class="headerlink" href="#combos0" title="Permalink to this definition">¶</a></dt>
<dd><p>Core recursive function for <a class="reference internal" href="#combos" title="combos"><code class="xref js js-func docutils literal notranslate"><span class="pre">combos()</span></code></a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>List</strong> (<em>array</em>) – logic formula, especially one with “or” or “and” subterms.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>array</strong> – returns logic formula where disjunctive or conjunctive subterms have been recombined</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="has">
<code class="descname">has</code><span class="sig-paren">(</span><em>X</em>, <em>V</em>, <em>cond=false</em><span class="sig-paren">)</span><a class="headerlink" href="#has" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if a term has a particular value (which may be another term). Expects a Negation Normal Form (NNF) list of terms,  NOT A FORMULA, because it needs to examine the term type to decide how to handle the search. The parameter “cond” controls if conditional terms need to be searched in general, for disjunctive lists, don’t search the conditionals, but for conjunctive lists, do.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>X</strong> (<em>*</em>) – string of type “Variable” or term</li>
<li><strong>V</strong> (<em>array</em>) – term to search in</li>
<li><strong>cond</strong> (<em>boolean</em>) – boolean to control whether to search within conditional terms</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>boolean</strong> – returns true if V contains X.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="equals">
<code class="descname">equals</code><span class="sig-paren">(</span><em>X</em>, <em>Y</em><span class="sig-paren">)</span><a class="headerlink" href="#equals" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two formulas (arrays), unordered except for the first element (i.e. the operator in formulas) or where the formula is a conditional. The <a class="reference internal" href="#equals" title="equals"><code class="xref js js-func docutils literal notranslate"><span class="pre">equals()</span></code></a> function will also compare objects.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>X</strong> (<em>array</em>) – first formula to compare with…</li>
<li><strong>Y</strong> (<em>array</em>) – …second formula</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>boolean</strong> – - <cite>true</cite> if X equals Y, otherwise <cite>false</cite></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="typet">
<code class="descname">typet</code><span class="sig-paren">(</span><em>T</em><span class="sig-paren">)</span><a class="headerlink" href="#typet" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the type of a term in a formula</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>T</strong> (<em>*</em>) – string of type “Variable” or term (i.e. array where first element is an operator)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>string</strong> – the term type of T</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="type">
<code class="descname">type</code><span class="sig-paren">(</span><em>X</em><span class="sig-paren">)</span><a class="headerlink" href="#type" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the javascript type of the value of X</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>X</strong> (<em>*</em>) – any valid js type</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>string</strong> – type of X</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The very core section of the calculator is the one that actually calculates probabilities.  It expects very simple DNF formulas, which are essentially lists of conjunctions of variables (i.e. no “divide” operator).  It then looks up the probabilities of each term in a conjunction and multiplies those together, after which it sums all the resulting probabilities.</p>
<dl class="function">
<dt id="prob">
<code class="descname">prob</code><span class="sig-paren">(</span><em>Formula</em>, <em>Net</em><span class="sig-paren">)</span><a class="headerlink" href="#prob" title="Permalink to this definition">¶</a></dt>
<dd><p>Process a DNF probability formula and calculate the resulting numerical probability</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>Formula</strong> (<em>array</em>) – a DNF formula</li>
<li><strong>Net</strong> (<em>object</em>) – a probability network object</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>real</strong> – - probability Note 1: expects that rules for conditional transformations (i.e. “given” to “divide”) is handled by DNF processing – so, no divides-by-zero</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="jprobs">
<code class="descname">jprobs</code><span class="sig-paren">(</span><em>F</em>, <em>Net</em><span class="sig-paren">)</span><a class="headerlink" href="#jprobs" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate the probabilities of a (disjunctive) list of conjunctions. Expects a disjunction (DNF).</p>
<p>The simplest case is something like <cite>[or, [and,[not,’X’],[not,’Y’]], [and,[not,’X’],’Y’], [and,’X’,[not,’Y’]], [and,’X’,’Y’] ]</cite>. Here we convert every conjunction to its index value, based on whether a variable is true in the term. So, for the terms in the example, the binary values would be 00,01,10,11, respectively – meaning index values of 0,1,2,3. We then look up the probability associated with that index (i.e. with that combination of variables) in the probability network.</p>
<p>Two complications need to be handled.  One is missing variables.  For example, if we encounter a term <cite>X</cite> by itself, then we might need to expand that to <cite>[or,[and,’X’,[not,’Y’]],[and,’X’,’Y’]]</cite>, depending on which variables are present in the probability network. This expansion is handled by the function <a class="reference internal" href="#allvars" title="allvars"><code class="xref js js-func docutils literal notranslate"><span class="pre">allvars()</span></code></a>. When this happens, we have to process each expanded term separately, which is handled in the inner <cite>for</cite> loop.</p>
<p>The second complication is that, if we expand terms, we have to avoid processing duplicates.  This is handled by marking each term that we’ve already encountered in a bitmap and skipping over terms whose bit is already set.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>F</strong> (<em>array</em>) – disjunction formula</li>
<li><strong>Net</strong> (<em>object</em>) – probability network</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>real</strong> – - probability</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="jprob">
<code class="descname">jprob</code><span class="sig-paren">(</span><em>Vars</em>, <em>Net</em><span class="sig-paren">)</span><a class="headerlink" href="#jprob" title="Permalink to this definition">¶</a></dt>
<dd><p>Lookup the joint probability of a conjunction of simple terms.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>Vars</strong> (<em>array</em>) – a conjunction of variables or negations of variables</li>
<li><strong>Net</strong> (<em>object</em>) – a probability network</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>real</strong> – returns the probability of the conjunction</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="allvars">
<code class="descname">allvars</code><span class="sig-paren">(</span><em>L</em>, <em>Vars</em><span class="sig-paren">)</span><a class="headerlink" href="#allvars" title="Permalink to this definition">¶</a></dt>
<dd><p>Expand a variable combination in a formula to include all combinations when some possible variables are missing. Expects L to be a conjunction of variables or their negations.
For example, <cite>allvars([‘X’],[‘X’,’Y’])</cite> will return <cite>[[X,[not,’Y’]],[‘X’,’Y’]]</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>L</strong> (<em>array</em>) – list of variables or negations of variables</li>
<li><strong>Vars</strong> (<em>array</em>) – list of possible variables</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>array</strong> – returns an expanded list of terms if any variables were missing from the original</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="getvars">
<code class="descname">getvars</code><span class="sig-paren">(</span><em>L</em><span class="sig-paren">)</span><a class="headerlink" href="#getvars" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract all variables from a list</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first last simple">
<li><strong>L</strong> (<em>array</em>) – formula or list. Variables are defined as alphanumeric strings that start with an uppercase letter.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="getvars0">
<code class="descname">getvars0</code><span class="sig-paren">(</span><em>L</em>, <em>Res</em><span class="sig-paren">)</span><a class="headerlink" href="#getvars0" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursive subfunction to extract all variables from a list</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first last simple">
<li><strong>L</strong> (<em>array</em>) – formula or list. Variables are defined as alphanumeric strings that start with an uppercase letter.</li>
<li><strong>Res</strong> (<em>array</em>) – already collected variables</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bcombos">
<code class="descname">bcombos</code><span class="sig-paren">(</span><em>L</em><span class="sig-paren">)</span><a class="headerlink" href="#bcombos" title="Permalink to this definition">¶</a></dt>
<dd><p>All positive and negative combinations of a list of variables, e.g. [X,Y] becomes [ [[not,X],[not,Y]], [[not,X],Y], [X,[not,Y]], [X,Y] ]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>L</strong> (<em>array</em>) – list of variables</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>array</strong> – returns all positive and negative combinations of a list of variables</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="x2v">
<code class="descname">x2v</code><span class="sig-paren">(</span><em>X</em>, <em>Vs</em><span class="sig-paren">)</span><a class="headerlink" href="#x2v" title="Permalink to this definition">¶</a></dt>
<dd><p>Translate an index of a binary-count ordered list into the boolean combination of variables.  For example, if the alphabetically sorted variable list is X,Y then [not,X],[not,Y] = 0, [not,X],Y = 1, X,[not,Y]=2 and X,Y=3.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>X</strong> (<em>integer</em>) – index for binary-count ordered list of variable combinations</li>
<li><strong>Vs</strong> (<em>array</em>) – list of strings of type “Variable”</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>array</strong> – returns the boolean combination of variables that represents the index value</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="x2vsub">
<code class="descname">x2vsub</code><span class="sig-paren">(</span><em>X</em>, <em>Vs</em>, <em>Varlist</em><span class="sig-paren">)</span><a class="headerlink" href="#x2vsub" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an index that represents the combination of boolean variables (from the variables list Vs) into a list of variable combinations from the list Varlist.</p>
<p>The idea here is that Vs is a subset of Varlist, so that the index of the sublist might match more than one combination of variables in Varlist.  For example, if Vs=[X,Y] and Varlist=[X,Y,Z], then the index value of 2 represents [[not,X],Y] in the combinations from Vs.  However, that expands into [ [[not,X],Y,[not,Z]], [[not,X],Y,Z] ] relative to the larger set of variables in Varlist.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>X</strong> (<em>integer</em>) – index for a binary-count ordered list of variable combinations</li>
<li><strong>Vs</strong> (<em>array</em>) – list of strings of type “Variable”</li>
<li><strong>Varlist</strong> (<em>array</em>) – complete list of available strings of type “Variable”</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>array</strong> – returns the boolean combination of variables that represents the index</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="v2x">
<code class="descname">v2x</code><span class="sig-paren">(</span><em>Terms</em><span class="sig-paren">)</span><a class="headerlink" href="#v2x" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a term list (i.e. list of variables or their negations) to a binary count order index. For example, [not,X],[not,Y] = 0, [not,X],Y = 1, X,[not,Y]=2 and X,Y=3</p>
<p>First we extract all variables from the list, which we then use to get the index of the particular combination.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>Terms</strong> (<em>array</em>) – list of variables or negations of variables</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>integer</strong> – returns the index value of the given boolean combination of variables</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="vars2x">
<code class="descname">vars2x</code><span class="sig-paren">(</span><em>T</em>, <em>Vs</em><span class="sig-paren">)</span><a class="headerlink" href="#vars2x" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a term list (i.e. list of variables or their negations) to a binary count order index, based on a list of variables. For example, for the variable list [X,Y], we have the following indices for boolean combinations of the variables: [not,X],[not,Y] = 0, [not,X],Y = 1, X,[not,Y]=2 and X,Y=3</p>
<p>First we extract all variables from the list, which we then use to get the index of the particular combination.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>T</strong> (<em>array</em>) – the given boolean combination variables or negations of variables</li>
<li><strong>Vs</strong> (<em>array</em>) – the list of possible variables</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>integer</strong> – returns the index value of the given boolean combination of variables</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="x2x">
<code class="descname">x2x</code><span class="sig-paren">(</span><em>X</em>, <em>Vs</em>, <em>Varlist</em><span class="sig-paren">)</span><a class="headerlink" href="#x2x" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert index of boolean combination of variables from a (sub)list into the indices for a (super)set of variables. See also <a class="reference internal" href="#x2vsub" title="x2vsub"><code class="xref js js-func docutils literal notranslate"><span class="pre">x2vsub()</span></code></a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>X</strong> (<em>integer</em>) – index representing a boolean combination of variables</li>
<li><strong>Vs</strong> (<em>array</em>) – list of variables used in X</li>
<li><strong>Varlist</strong> (<em>array</em>) – (larger) list of available variables</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ingeger</strong> – -</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="product">
<code class="descname">product</code><span class="sig-paren">(</span><em>L</em><span class="sig-paren">)</span><a class="headerlink" href="#product" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply probabilities in a list using log transformation</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first simple">
<li><strong>L</strong> (<em>array</em>) – list of real values (0 &lt;= x &lt;=1) i.e. probabilities</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>real</strong> – returns the product of the values in the list</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="BitArray">
<em class="property">class </em><code class="descname">BitArray</code><span class="sig-paren">(</span><em>totalbits</em><span class="sig-paren">)</span><a class="headerlink" href="#BitArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Simple BitArray implementation</p>
<p>Methods: <cite>zero</cite> to zero out all bits, <cite>setbit</cite> to set a bit, <cite>getbit</cite> to get the value of a bit, <cite>unsetbit</cite> to set a bit to zero, <cite>getones</cite> to get a list of indices of all the bits that are set to <cite>true</cite>, <cite>bitsum</cite> to get the total number of bits that are set to one.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first last simple">
<li><strong>totalbits</strong> (<em>integer</em>) – total number of bits that the BitArray should cover – i.e. the minimum size of the bitarray in bits. The actual size is sometimes larger, because the array is implemented in 8-bit increments (bytes).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="#">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Welcome to pcalc’s source code documentation!</a><ul>
<li><a class="reference internal" href="#overview">Overview</a><ul>
<li><a class="reference internal" href="#overview-of-the-interpreter-sub-module">Overview of the interpreter sub-module</a></li>
<li><a class="reference internal" href="#overview-of-the-probability-calculator-sub-module">Overview of the probability calculator sub-module</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#indices-and-tables">Indices and tables</a><ul>
<li><a class="reference internal" href="#the-main-interface-to-the-probability-calculator">The main interface to the probability calculator</a></li>
<li><a class="reference internal" href="#the-calculator-formula-interpreter">The calculator formula interpreter</a></li>
<li><a class="reference internal" href="#the-core-probability-calculator">The core probability calculator</a></li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="#">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/index.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, Richard de Rozario.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.7.5</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.11</a>
      
      |
      <a href="_sources/index.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>